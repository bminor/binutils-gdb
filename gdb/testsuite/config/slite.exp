#   Copyright (C) 1993 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# DejaGnu@cygnus.com

# This file was written by Ian Lance Taylor <ian@cygnus.com>.

# GDB support routines for a board using the MIPS remote debugging
# protocol.  These are actually pretty generic.

# DejaGnu currently assumes that debugging is being done over the main
# console port.  It would probably be more convenient for people using
# IDT boards to permit the debugging port and the connected port to be
# different, since an IDT board has two ports.  This would require
# extending some of the tests in a fashion similar to that done for
# VxWorks, because the test output would appear on the other port,
# rather than being displayed by gdb.

load_lib remote.exp
load_lib gdb.exp
set prompt "\\(gdb\\)"

#
# gdb_load -- load a file into the GDB. 
#             Returns a 0 if there was an error,
#                       1 if it load successfully.
#
proc gdb_load { arg } {
    global verbose
    global loadpath
    global loadfile
    global prompt
    global GDB
    global expect_out
    global gdb_spawn_id

    set loadfile [file tail $arg]
    set loadpath [file dirname $arg]

    send_gdb "file $arg\n"
    expect {
	-i $gdb_spawn_id -re "A program is being debugged already..*Kill it.*y or n. $" {
	    send_gdb "y\n"
	    exp_continue
	}
        -i $gdb_spawn_id -re "Load new symbol table.*y or n. $" {
	    send_gdb "y\n"
	    exp_continue
	}
	-i $gdb_spawn_id -re "Reading symbols from.*done..*$prompt $" {}
	-i $gdb_spawn_id -re "$prompt $" { perror "GDB couldn't read file" }
	-i $gdb_spawn_id timeout { perror "(timeout) read symbol file" ; return -1 }
    }

    if [target_info exists gdb_protocol] {
	set protocol [target_info gdb_protocol];
    } else {
	set protocol "sparclite"
    }

    if [target_info exists serial] {
	set targetname [target_info serial];
	send_gdb "target $protocol [target_info serial]\n";
    } else {
	if ![target_info exists netport] {
	    perror "Need either netport or gdb_serial entry for [target_info name].";
	    return -1;
	}
	set targetname [target_info netport];
	send_gdb "target $protocol udp [target_info netport]\n";
    }
    set timeout 60
    verbose "Timeout is now $timeout seconds" 2
    expect {
	-i $gdb_spawn_id -re "Remote target.*$prompt $" { }
	-i $gdb_spawn_id -re ".*SPARClite appears to be alive.*$prompt $"	{
	    if $verbose>1 then {
		send_user "Set target to $targetname\n"
	    }
	}
	-i $gdb_spawn_id timeout { 
	    perror "Couldn't set SLITE target."
	    set timeout 10
	    verbose "Timeout is now $timeout seconds" 2
	    return -1
	}
    }
    
    if [target_info exists gdb_load_offset] {
	set offset "[target_info gdb_load_offset]";
    } else {
	set offset "";
    }
    if { 1 } {
	send_gdb "load $arg $offset\n"
	verbose "Loading $arg into $GDB" 2
	set timeout 2400
	verbose "Timeout is now $timeout seconds" 2
	expect {
	    -i $gdb_spawn_id -re "Loading.*$prompt $" {
		verbose "Loaded $arg into $GDB" 1
		set timeout 30
		verbose "Timeout is now $timeout seconds" 2
	    }
	    -i $gdb_spawn_id -re "$prompt $"     {
		if $verbose>1 then {
		    perror "GDB couldn't load."
		}
	    }
	    -i $gdb_spawn_id timeout {
		if $verbose>1 then {
		    perror "Timed out trying to load $arg."
		}
	    }
	}
    }
    set timeout 10
    verbose "Timeout is now $timeout seconds, doing monitor run" 2
    send_gdb "monitor run\n";
    sleep 2;
    send_gdb "";
    expect {
	-i $gdb_spawn_id -re ".*$prompt $" { verbose "Run command succeded" }
	-i $gdb_spawn_id default {
	    perror "error sending monitor run command";
	}
    }

    if [target_info exists gdb_serial] {
	send_gdb "target remote [target_info gdb_serial]\n"
	set timeout 60
	verbose "Timeout is now $timeout seconds" 2
	expect {
	    -i $gdb_spawn_id -re ".*Kill it?.*y or n.*" {
		send_gdb "y\n";
		exp_continue
	    }
	    -i $gdb_spawn_id -re ".*$prompt $"	{
		verbose "Set remote target to [target_info serial]" 2
	    }
	    -i $gdb_spawn_id timeout { 
		perror "Couldn't set remote target."
		set timeout 10
		verbose "Timeout is now $timeout seconds" 2
		return -1
	    }
	}
    }

    if [info exists expect_out(buffer)] then {
	send_log $expect_out(buffer)
    }
    return 0
}
