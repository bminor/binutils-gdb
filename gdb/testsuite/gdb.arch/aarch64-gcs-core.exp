# Copyright 2025 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Test reading and writing the core dump of a binary that uses a Guarded
# Control Stack.

require allow_aarch64_gcs_tests

standard_testfile

if { [prepare_for_testing "failed to prepare" $testfile $srcfile] } {
    return
}

set linespec ${srcfile}:[gdb_get_line_number "Break here"]

if {![runto $linespec]} {
    return
}

# Obtain an OS-generated core file.  Save test program output to
# ${binfile}.out.
set core_filename [core_find $binfile {} {} "${binfile}.out"]
set core_generated [expr {$core_filename != ""}]

# Make sure GDB can read the given core file correctly.
proc check_core_file {core_filename saved_gcspr} {
    global decimal hex

    # Load the core file.
    if {[gdb_test "core $core_filename" \
	     [multi_line \
		  "Core was generated by .*\\." \
		  "Program terminated with signal SIGSEGV, Segmentation fault" \
		  "Guarded Control Stack error\\." \
		  "#0  function \\(gcspr=$hex\\) at .*aarch64-gcs-core.c:$decimal" \
		  "$decimal.*__asm__ volatile \\(\"ret\\\\n\"\\);"] \
	     "load core file"]} {
	return -1
    }

    # Check the value of GCSPR in the core file.
    gdb_test "print/x \$gcspr" "\\$\[0-9\]+ = $saved_gcspr" \
	"gcspr contents from core file"
}

if {!$core_generated} {
    untested "unable to create or find corefile"
}

if {$core_generated} {
    clean_restart
    gdb_load $binfile

    with_test_prefix "OS corefile" {
	# Read GCSPR value from saved output of the test program.
	set out_id [open ${binfile}.out "r"]
	set gcspr_in_core [gets $out_id]
	close $out_id

	check_core_file $core_filename $gcspr_in_core
    }
}

if {![gcore_cmd_available]} {
    unsupported "target does not support gcore command."
    return
}

clean_restart
gdb_load $binfile

if {![runto $linespec]} {
    return
}

# Continue until a crash.  The line with the hex number is optional because
# it's printed by the test program, and doesn't appear in the Expect buffer
# when testing a remote target.
gdb_test "continue" \
    [multi_line \
	 "Continuing\\." \
	 "($hex\r\n)?" \
	 "Program received signal SIGSEGV, Segmentation fault" \
	 "Guarded Control Stack error\\." \
	 "function \\(gcspr=$hex\\) at .*aarch64-gcs-core.c:$decimal" \
	 {.*__asm__ volatile \("ret\\n"\);}] \
    "continue to SIGSEGV"

set gcspr_in_gcore [get_valueof "/x" "\$gcspr" "*unknown*"]

# Generate the gcore core file.
set gcore_filename [standard_output_file "${testfile}.gcore"]
set gcore_generated [gdb_gcore_cmd "$gcore_filename" "generate gcore file"]

gdb_assert { $gcore_generated } "gcore corefile created"
if {$gcore_generated} {
    clean_restart
    gdb_load $binfile

    with_test_prefix "gcore corefile" {
	check_core_file $gcore_filename $gcspr_in_gcore
    }
}
