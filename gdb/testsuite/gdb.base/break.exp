#   Copyright (C) 1988, 1990, 1991, 1992, 1994 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu

# This file was written by Rob Savoye. (rob@cygnus.com)

if $tracelevel then {
	strace $tracelevel
	}

#
# test running programs
#
set prms_id 0
set bug_id 0

set binfile "break"
set srcfile $binfile.c

if ![file exists $objdir/$subdir/$binfile] then {
    perror "$objdir/$subdir/$binfile does not exist."
    return 0
}

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load $objdir/$subdir/$binfile

#
# test simple breakpoint setting commands
#

#
# test deleting all breakpoints; note that gdb-init.exp provides a
# "delete_breakpoints" proc for general use elsewhere
#
send "delete breakpoints\n"
expect {
    -re "Delete all breakpoints.*y or n. $"\
	{ send "y\n"
	    expect {
		-re ".*$prompt $"\
		    { send "info breakpoints\n"
			expect {
			    -re "No breakpoints or watchpoints..*$prompt $" { pass "Deleted all breakpoints" }
			    -re ".*$prompt $"       { fail "Deleted all breakpoints" }
			    timeout	            { fail "Deleted all breakpoints" }
			}
		    }
		timeout	            { fail "Deleted all breakpoints" }	    
	    }
	}
    -re ".*$prompt $"       { fail "Deleted all breakpoints" }
    timeout	            { fail "Deleted all breakpoints" }
}

#
# test break at function
#
gdb_test "break main" \
    "Breakpoint.*at.* file .*$srcfile, line.*" \
    "breakpoint function"

#
# test break at function in file
#
gdb_test "break $srcfile:factorial" \
    "Breakpoint.*at.* file .*$srcfile, line.*" \
    "breakpoint function in file"

#
# test break at line number
#
gdb_test "break 64" \
    "Breakpoint.*at.* file .*$srcfile, line 64\\." \
    "breakpoint line number"

#
# test duplicate breakpoint
#
gdb_test "break 64" \
    "Note: breakpoint \[0-9\]+ also set at pc.*Breakpoint \[0-9\]+ at.* file .*$srcfile, line 64\\." \
    "breakpoint duplicate"

#
# test break at line number in file
#
gdb_test "break $srcfile:70" \
    "Breakpoint.*at.* file .*$srcfile, line 70\\." \
    "breakpoint line number in file"


#
# check to see what breakpoints are set
#
gdb_test "info break" \
    "Num Type\[ \]+Disp Enb Address\[ \]+What.*
\[0-9\]+\[\t \]+breakpoint     keep y.* in main at .*$srcfile:60.*
\[0-9\]+\[\t \]+breakpoint     keep y.* in factorial at .*$srcfile:76.*
\[0-9\]+\[\t \]+breakpoint     keep y.* in main at .*$srcfile:64.*
\[0-9\]+\[\t \]+breakpoint     keep y.* in main at .*$srcfile:64.*
\[0-9\]+\[\t \]+breakpoint     keep y.* in main at .*$srcfile:70" \
    "breakpoint info"


# FIXME: The rest of this test doesn't work with anything that can't
# handle arguments.
if [istarget "mips-idt-*"] then {
    return
}

#
# run until the breakpoint at main is hit. For non-stubs-using targets.
#
if !$usestubs then {
  if [istarget "*-*-vxworks*"] then {
    send "run vxmain \"2\"\n"
    set timeout 120
  } else {
	send "run\n"
  }
  expect {
    -re "Starting program.*Breakpoint \[0-9\]+,.*main .*argc.*argv.* at .*$srcfile:60.*60\[\t \]+if .argc.* \{.*$prompt $"\
	                    { pass "run until function breakpoint" }
    -re ".*$prompt $"       { fail "run until function breakpoint" }
    timeout	            { fail "(timeout) run until function breakpoint" }
  }
}

#if $usestubs {}

#
# run until the breakpoint at a line number
#
gdb_test continue "Continuing\\..*Breakpoint \[0-9\]+, main \\(argc=.*, argv=.*, envp=.*\\) at .*$srcfile:64.*64\[\t \]+printf.*factorial.*" \
			"run until breakpoint set at a line number"

#
# Run until the breakpoint set in a function in a file
#
for {set i 6} {$i >= 1} {incr i -1} {
	gdb_test continue "Continuing\\..*Breakpoint \[0-9\]+, factorial \\(value=$i\\) at .*$srcfile:76.*76\[\t \]+if .value > 1. \{" \
			"run until file:function($i) breakpoint"
}

#
# run until the file:function breakpoint at a line number in a file
#
gdb_test continue "Continuing\\..*Breakpoint \[0-9\]+, main \\(argc=.*, argv=.*, envp=.*\\) at .*$srcfile:70.*70\[\t \]+return 0;" \
		"run until file:linenum breakpoint"

#
# delete all breakpoints so we can start over, course this can be a test too
#
send "delete breakpoints\n"
expect {
    -re "Delete all breakpoints.*y or n.*$" {
	send "y\n"
	expect {
	    -re ".*$prompt $" {
		send "info breakpoints\n"
		expect {
		    -re "No breakpoints or watchpoints..*$prompt $" {
			pass "Deleted all breakpoints"
		    }
		    -re ".*$prompt $"       { fail "Deleted all breakpoints" }
		    timeout	            { fail "Deleted all breakpoints" }
		}
	    }
	    timeout	            { fail "Deleted all breakpoints" }	    
	}
    }
    -re ".*$prompt $"       { fail "Deleted all breakpoints" }
    timeout	            { fail "Deleted all breakpoints" }
}


#
# test temporary breakpoint at function
#

gdb_test "tbreak main" "Breakpoint.*at.* file .*$srcfile, line.*" "Temporary breakpoint function"

#
# test break at function in file
#

gdb_test "tbreak $srcfile:factorial" "Breakpoint.*at.* file .*$srcfile, line.*" \
	"Temporary breakpoint function in file"

#
# test break at line number
#
send "tbreak 64\n"
expect {
    -re "Breakpoint.*at.* file .*$srcfile, line 64.*$prompt $" { pass "Temporary breakpoint line number" }
	-re ".*$prompt $"   { pass "Temporary breakpoint line number" }
	timeout	    { fail "(timeout) breakpoint line number" }
}

gdb_test "tbreak 60" "Breakpoint.*at.* file .*$srcfile, line 60.*" "Temporary breakpoint line number"

#
# test break at line number in file
#
send "tbreak $srcfile:70\n"
expect {
    -re "Breakpoint.*at.* file .*$srcfile, line 70.*$prompt $" { pass "Temporary breakpoint line number in file" }
	-re ".*$prompt $"   { pass "Temporary breakpoint line number in file" }
	timeout	    { fail "(timeout) breakpoint line number in file" }
}

gdb_test  "tbreak $srcfile:66" "Breakpoint.*at.* file .*$srcfile, line 66.*" "Temporary breakpoint line number in file"

#
# check to see what breakpoints are set (temporary this time)
#
send "info break\n"
expect {
    -re "Num Type.*Disp Enb Address.*What.*
\[0-9\]+\[\t \]+breakpoint     del.*y.*in main at .*$srcfile:60.*
\[0-9\]+\[\t \]+breakpoint     del.*y.*in factorial at .*$srcfile:76.*
\[0-9\]+\[\t \]+breakpoint     del.*y.*in main at .*$srcfile:64.*
\[0-9\]+\[\t \]+breakpoint     del.*y.*in main at .*$srcfile:70.*$prompt $" {
        pass "Temporary breakpoint info"
    }
    -re ".*$prompt $"   { fail "Temporary breakpoint info" }
    timeout	    { fail "(timeout) Temporary breakpoint info" }
}

proc test_clear_command {} {
    gdb_test "break main" "Breakpoint.*at.*"
    gdb_test "break main" "Breakpoint.*at.*"

    # We don't test that it deletes the correct breakpoints.  We do at
    # least test that it deletes more than one breakpoint.
    gdb_test "clear main" {Deleted breakpoints [0-9]+ [0-9]+.*}
}

#
# Test "next" over recursive function call.
#

proc test_next_with_recursion {} { 
   global prompt
   global decimal

# FIXME: should be using runto
    send "kill\n"
    expect {
	-re ".*Kill the program being debugged.*y or n. $" {
	    send "y\n"
	    exp_continue
	}
	-re ".*$prompt $" {}
	timeout { fail "killing inferior" ; return }
    }

    delete_breakpoints

    gdb_test "break factorial" "Breakpoint $decimal at .*" "break at factorial"

    # Run until we call factorial with 6

    if [istarget "*-*-vxworks*"] then {
	send "run vxmain \"6\"\n"
    } else {
	    send "run\n"
    }
    expect {
	-re "Starting .*Break.* factorial .value=6. .*$prompt $" {}
	timeout { fail "run to factorial(6)" ; return }
    }

    # Continue until we call factorial recursively with 5.

    send "continue\n"
    expect {
	-re "Continuing.*Break.* factorial .value=5. .*$prompt $" {}
	timeout { fail "continue to factorial(5)" ; return }
    }

    # Do a backtrace just to confirm how many levels deep we are.

    set result [gdb_test "backtrace" \
			"#0\[ \t\]+ factorial .value=5..*" \
			"backtrace from factorial(5)"]
    if $result!=0 then { return }

    # Now a "next" should position us at the recursive call, which
    # we will be performing with 4.

    send "next\n"
    expect {
	-re ".* factorial .value - 1.;.*$prompt $" {}
	timeout { fail "next to recursive call (timeout)" ; return }
    }

    # Disable the breakpoint at the entry to factorial by deleting them all.
    # The "next" should run until we return to the next line from this
    # recursive call to factorial with 4.
    # Buggy versions of gdb will stop instead at the innermost frame on
    # the line where we are trying to "next" to.

    delete_breakpoints

    gdb_test next "\[0-9\]*\[\t \]+return \\(value\\);.*" \
	"next over recursive call"

    # OK, we should be back in the same stack frame we started from.
    # Do a backtrace just to confirm.

    set result [gdb_test "backtrace" \
			 "#0\[ \t\]+ factorial .value=120.*\r\n#1\[ \t\]+ \[0-9a-fx\]+ in factorial .value=6..*" \
			 "backtrace from factorial(5)"]
    if $result!=0 then { return }

    # Continue until we exit.  Should not stop again.
    gdb_test "continue" "Continuing.\r\n720\r\n\r\nProgram exited normally\\."\
		"continue until exit in recursive next test"
}

test_clear_command
test_next_with_recursion

# Reset the default arguments for VxWorks
if [istarget "*-*-vxworks*"] then {
    set timeout 10
    send "set args main\n"
    expect -re ".*$prompt $" {}
}
