# Copyright 1992-2025 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This file was written by Fred Fish. (fnf@cygnus.com)


# are we on a target board
require isnative

standard_testfile coremaker.c

if {[build_executable $testfile.exp $testfile $srcfile debug] == -1} {
    untested "failed to compile"
    return -1
}

# Do not delete coremap.data when calling core_find.  This file is
# required for GDB to find mmap'd data in the "accessing read-only
# mmapped data in core file" test.
set corefile [core_find $binfile {}]
if {$corefile == ""} {
    untested "unable to create or find corefile"
    return 0
}

# Start GDB with COREFILE passed as a command line argument.  COREOPT
# is prefixed before COREFILE and is the command line flag to specify
# the corefile, i.e. one of '--core=', '-core=', '-c '.
#
# If BINFILE is not the empty string then it is also added as a
# command line argument and is the executable to load.
#
# TESTNAME is used for naming the tests.
proc start_gdb_with_corefile { testname coreopt corefile {binfile ""} } {
    gdb_exit

    global GDBFLAGS

    save_vars { GDBFLAGS } {
	append GDBFLAGS " $binfile $coreopt$corefile"
	set res [gdb_spawn]
	if { $res != 0 } {
	    fail "$testname (start GDB)"
	    return
	}

	gdb_test_multiple "" $testname {
	    -re -wrap "Couldn't find .* registers in core file.*" {
		fail "$gdb_test_name (couldn't find regs)"
	    }
	    -re -wrap "Core was generated by `[string_to_regexp $binfile]'\\.\r\n.*\#0  \[^\r\n\]+\(\).*" {
		pass $gdb_test_name
	    }
	    -re -wrap "Core was generated by .*\r\n\#0  .*\(\).*" {
		# This case is hit when the executable name is
		# truncated in the output.
		pass "$gdb_test_name (with bad program name)"
	    }
	    -re -wrap ".*registers from core file: File in wrong format.*" {
		fail "$gdb_test_name (could not read registers from core file)"
	    }
	    -re -wrap "" {
		fail "$gdb_test_name (core not loaded)"
	    }
	}

	# COREFILE will have whitespace quoted ready for use on the command
	# line.  But for the 'info inferiors' output whitespace is not quoted,
	# so remote the quoting now.
	regsub -all "\\\\ " $corefile " " corefile
	gdb_test "info inferiors" \
	    [multi_line \
		 "\\* 1\[^\r\n\]+\\(core\\)\\s+.*[string_to_regexp $binfile]\\s*" \
		 "\\s+core file [string_to_regexp $corefile]"] \
	    "$testname, info inferiors"
    }
}

# Create a copy of the corefile, but with a space in the filename.
set alt_corefile [standard_output_file "core\\ file.core"]
remote_exec host "cp $corefile $alt_corefile"

# Test that we can start GDB with a corefile command line argument and
# recognize that the core file is a valid, usable core file.  We test
# using '--core=...', '-core=...', and '-c ...' style arguments.  We
# also test with, and without an executable.
foreach_with_prefix coreopt {--core= -core= "-c "} {
    start_gdb_with_corefile "just core file" $coreopt $corefile
    start_gdb_with_corefile "core file and executable" $coreopt $corefile $binfile
    start_gdb_with_corefile "core file with white space in name" \
	$coreopt $alt_corefile
    start_gdb_with_corefile "core file with white space in name and executable" \
	$coreopt $alt_corefile $binfile
}

# Now restart normally.

clean_restart $testfile

# Test basic corefile recognition via core-file command.

gdb_test_multiple "core-file $corefile" "core-file command" {
    -re ".* program is being debugged already.*y or n. $" {
	# gdb_load may connect us to a gdbserver.
	send_gdb "y\n"
	exp_continue
    }
    -re "Core was generated by .*corefile.*\r\n\#0  .*\(\).*\r\n$gdb_prompt $" {
	pass "core-file command"
    }
    -re "Core was generated by .*\r\n\#0  .*\(\).*\r\n$gdb_prompt $" {
	pass "core-file command (with bad program name)"
    }
    -re ".*registers from core file: File in wrong format.* $" {
	fail "core-file command (could not read registers from core file)"
    }
}

# Test correct mapping of corefile sections by printing some variables.

gdb_test "print coremaker_data" "\\\$$decimal = 202"
gdb_test "print coremaker_bss" "\\\$$decimal = 10"
gdb_test "print coremaker_ro" "\\\$$decimal = 201"

gdb_test "print func2::coremaker_local" "\\\$$decimal = \\{0, 1, 2, 3, 4\\}"

# Test the presence and the correct values of $_exitsignal and
# $_exitcode variables.  The corefile is generated with a SIGABRT,
# which is "6" in the Linux kernel.

gdb_test "print \$_exitsignal" " = 6" \
    "\$_exitsignal prints SIGABRT (6)"

gdb_test "print \$_exitcode" " = void" \
    "\$_exitcode is void"

# Somehow we better test the ability to read the registers out of the core
# file correctly.  I don't think the other tests do this.

gdb_test "bt" "abort.*func2.*func1.*main.*" "backtrace"
gdb_test "up" "#\[0-9\]* *(\[0-9xa-fH'\]* in)? .* \\(.*\\).*" "up"

# Test ability to read mmap'd data

gdb_test "x/8bd buf1" ".*:.*0.*1.*2.*3.*4.*5.*6.*7" "accessing original mmap data in core file"
setup_xfail "*-*-sunos*" "*-*-aix*"
set test "accessing mmapped data in core file"
gdb_test_multiple "x/8bd buf2" "$test" {
    -re ".*:.*0.*1.*2.*3.*4.*5.*6.*7.*$gdb_prompt $" {
	pass "$test"
    }
    -re "0x\[f\]*:.*Cannot access memory at address 0x\[f\]*.*$gdb_prompt $" {
	fail "$test (mapping failed at runtime)"
    }
    -re "0x.*:.*Cannot access memory at address 0x.*$gdb_prompt $" {
	fail "$test (mapping address not found in core file)"
    }
}

set test "accessing read-only mmapped data in core file"
gdb_test_multiple "x/8bd buf2ro" "$test" {
    -re ".*:.*0.*1.*2.*3.*4.*5.*6.*7.*$gdb_prompt $" {
	pass "$test"
    }
    -re "0x\[f\]*:.*Cannot access memory at address 0x\[f\]*.*$gdb_prompt $" {
	fail "$test (mapping failed at runtime)"
    }
    -re "0x.*:.*Cannot access memory at address 0x.*$gdb_prompt $" {
	fail "$test (mapping address not found in core file)"
    }
}

# Test ability to read anonymous and, more importantly, unwritten-to
# mmap'd data.

if { ![istarget *-linux*] } {
    setup_xfail "*-*-*"
}
gdb_test "x/wx buf3" "$hex:\[ \t\]+0x00000000" \
	 "accessing anonymous, unwritten-to mmap data"

# test reinit_frame_cache

gdb_load ${binfile}
gdb_test "up" "#\[0-9\]* *(\[0-9xa-fH'\]* in)? .* \\(.*\\).*" "up, reinit"

gdb_test "core" "No core file now."

# Temporarily move coremmap.data out of the way and reload the core
# file.  We should still be able to read buf2 as the contents of this
# are written into the core file.  In contrast buf2ro should no longer
# be readable as the contents of this region are not within the core
# file, GDB relies on reading this from the coremmap.data file, which
# can no longer be found.
set coremmap_data_filename \
    [standard_output_file coredir.[getpid]/coremmap.data]
set coremmap_data_backup_filename \
    [standard_output_file coredir.[getpid]/coremmap.data.backup]
remote_exec host "mv ${coremmap_data_filename} \
		  ${coremmap_data_backup_filename}"

clean_restart $testfile

# Load the core file and check we get a warning about the
# coremmap.data file being missing.
gdb_test_multiple "core-file $corefile" "warn about coremmap.data missing" {
    -re -wrap "warning: Can't open file \[^\r\n\]+/coremmap.data during file-backed mapping note processing\r\n.*" {
	pass $gdb_test_name
    }
}

# This xfail was just copied from earlier in the script where we also
# read from buf2.
setup_xfail "*-*-sunos*" "*-*-aix*"
gdb_test "x/8bd buf2" \
    ".*:.*0.*1.*2.*3.*4.*5.*6.*7.*" \
    "accessing mmapped data in core file with coremmap.data removed"

gdb_test "x/8bd buf2ro" \
    "$hex\[^:\]*:\\s+Cannot access memory at address $hex" \
    "accessing read-only mmapped data in core file with coremmap.data removed"

# Restore the coremmap.data file so later tests don't give warnings
# when the core file is reloaded.
remote_exec host "mv ${coremmap_data_backup_filename} \
		  ${coremmap_data_filename}"

# Test that we can unload the core with the "detach" command.

proc_with_prefix corefile_detach {} {
    clean_restart $::testfile

    gdb_test "core-file $::corefile" "Core was generated by .*" "load core"
    gdb_test "detach" "No core file now\\." "detach core"
}

corefile_detach

# Test a run (start) command will clear any loaded core file.

proc corefile_test_run {} {
    global corefile gdb_prompt

    # This test is trying to check whether the "run" command finds the
    # default run target when already debugging a core, so it would
    # fail on boards that set auto-connect-native-target off.  Since
    # there's no real point in running the test but with the native
    # target, it's easier to just skip elsewhere.
    if {[target_info gdb_protocol] != ""} {
	return
    }

    clean_restart $::testfile

    gdb_test "core-file $corefile" "Core was generated by .*" "run: load core again"
    set re "Local core dump file:"
    gdb_test "pipe info files | grep \"$re\"" \
	"Local core dump file:" \
	"run: sanity check we see the core file"

    set test "run: with core"
    if {[runto_main]} {
	pass $test
    } else {
	fail $test
    }

    set test "run: core file is cleared"
    set re "Local core dump file:"
    gdb_test_multiple "pipe info files | grep \"$re\"" $test {
	-re -wrap $re {
	    fail $test
	}
	-re -wrap "" {
	    pass $test
	}
    }

    set test "quit with a process"
    gdb_test_multiple "quit" $test {
	-re "A debugging session is active.\r\n.*\r\nQuit anyway\\? \\(y or n\\) $" {
	    pass $test
	    gdb_test "n" {Not confirmed\.} "quit with processes: n"
	}
    }

    gdb_exit
}

corefile_test_run

# Verify there is no question if only a core file is loaded.

gdb_start
gdb_test "core-file $corefile" "Core was generated by .*" "no question: load core"

set test "quit with a core file"
gdb_test_multiple "quit" $test {
    -re "A debugging session is active.\r\n.*\r\nQuit anyway\\? \\(y or n\\) $" {
	fail $test
	gdb_test "n" {Not confirmed\.} "quit with processes: n"
    }
    eof {
	pass $test
    }
}

gdb_exit

# Test an attach command will clear any loaded core file.

proc corefile_test_attach {} {
    global binfile corefile gdb_prompt

    # This test is checking whether the "attach" command finds the
    # default run target when already debugging a core, so it would
    # fail on boards that set auto-connect-native-target off.  Since
    # there's no real point in running the test but with the native
    # target, it's easier to just skip elsewhere.
    if {[target_info gdb_protocol] != ""} {
	return
    }

    if {[can_spawn_for_attach]} {
	set test "attach: spawn sleep"
	set res [remote_spawn host "$binfile sleep"]
	if { $res < 0 || $res == "" } {
	    fail $test
	    return
	}
	set pid [exp_pid -i $res]
	# We don't care whether the program is still in the startup phase when we
	# attach.

	gdb_start

	gdb_test "core-file $corefile" "Core was generated by .*" "attach: load core again"

	# If GDB managed to auto-load an executable based on the core
	# file, then unload it now.
	gdb_test "with confirm off -- file" \
	    [multi_line \
		 "^No executable file now\\." \
		 "No symbol file now\\."] \
	    "ensure no executable is loaded"

	gdb_test "info files" "\r\nLocal core dump file:\r\n.*" "attach: sanity check we see the core file"

	gdb_test "attach $pid" "Attaching to process $pid\r\n.*" "attach: with core"

	set test "attach: core file is cleared"
	set re "Local core dump file:"
	gdb_test_multiple "pipe info files | grep \"$re\"" $test {
	    -re -wrap $re {
		fail $test
	    }
	    -re -wrap "" {
		pass $test
	    }
	}

	gdb_exit
    }
}

corefile_test_attach

# Test warning-free core file load.  E.g., a Linux vDSO used to
# trigger this warning:
#     warning: Can't read pathname for load map: Input/output error.
#
# When testing in a docker container using the AUFS storage driver,
# the kernel places host paths in the core file's NT_FILE note.  XFAIL
# this case since these paths make no sense in the container.

clean_restart ${testfile}

set test "core-file warning-free"
gdb_test_multiple "core-file $corefile" $test {
    -re "warning: Can\'t open file.*\/docker\/aufs\/.*\r\n$gdb_prompt $" {
	xfail $test
    }
    -re "warning: .*\r\n.*\r\n$gdb_prompt $" {
	fail $test
    }
    -re "\r\n$gdb_prompt $" {
	pass $test
    }
}
