# Copyright (C) 1992, 1994 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@cygnus.com)

if $tracelevel then {
	strace $tracelevel
}

set prms_id 0
set bug_id 0

set binfile "funcargs"
set srcfile $binfile.c

if ![file exists $objdir/$subdir/$binfile] then {
    perror "$objdir/$subdir/$binfile does not exist."
    return 0
}

#
# Locate actual args; integral types.
#

proc integral_args {} {
    global prompt
    global det_file

    delete_breakpoints

    send "break call0a\n" ; expect -re ".*$prompt $"
    send "break call0b\n" ; expect -re ".*$prompt $"
    send "break call0c\n" ; expect -re ".*$prompt $"
    send "break call0d\n" ; expect -re ".*$prompt $"
    send "break call0e\n" ; expect -re ".*$prompt $"

    # Run; should stop at call0a and print actual arguments.
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    send "run\n"
    expect {
	-re "The program .* has been started already.* \[(\]+y or n\[)\]+ $" {
	    send "y\n"
	    exp_continue
	}
	-re ".* call0a \[(\]+c=97 'a', s=1, i=2, l=3\[)\]+ .*$prompt $" {}
	-re "$prompt $"  { fail "run to call0a" ; return }
	timeout { fail "(timeout) run to call0a" ; return }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    send "print c\n"
    expect {
	-re ".* = 97 'a'\r\n$prompt $" {}
	-re "$prompt $" { fail "print c" ; return }
	timeout { fail "(timeout) print c" ; return }
    }
    send "print s\n"
    expect {
	-re ".* = 1\r\n$prompt $" {}
	-re "$prompt $" { fail "print s" ; return }
	timeout { fail "(timeout) print s" ; return }
    }
    send "print i\n"
    expect {
	-re ".* = 2\r\n$prompt $" {}
	-re "$prompt $" { fail "print i" ; return }
	timeout { fail "(timeout) print i" ; return }
    }
    send "print l\n"
    expect {
	-re ".* = 3\r\n$prompt $" {}
	-re "$prompt $" { fail "print l" ; return }
	timeout { fail "(timeout) print l" ; return }
    }

    # Continue; should stop at call0b and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call0b \[(\]+s=1, i=2, l=3, c=97 'a'\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call0b" ; return }
	timeout { fail "(timeout) continue to call0b" ; return }
    }

    # Continue; should stop at call0c and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call0c \[(\]+i=2, l=3, c=97 'a', s=1\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call0c" ; return }
	timeout { fail "(timeout) continue to call0c" ; return }
    }

    # Continue; should stop at call0d and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call0d \[(\]+l=3, c=97 'a', s=1, i=2\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call0d" ; return }
	timeout { fail "(timeout) continue to call0d" ; return }
    }

    # Continue; should stop at call0e and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call0e \[(\]+c1=97 'a', l=3, c2=97 'a', i=2, c3=97 'a', s=1, c4=97 'a', c5=97 'a'\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call0e" ; return }
	timeout { fail "(timeout) continue to call0e" ; return }
    }

    pass "locate actual args, signed integral types"
}

#
# Locate actual args; unsigned integral types.
#

proc unsigned_integral_args {} {
    global prompt
    global det_file

    delete_breakpoints

    send "break call1a\n" ; expect -re ".*$prompt $"
    send "break call1b\n" ; expect -re ".*$prompt $"
    send "break call1c\n" ; expect -re ".*$prompt $"
    send "break call1d\n" ; expect -re ".*$prompt $"
    send "break call1e\n" ; expect -re ".*$prompt $"

    # Run; should stop at call1a and print actual arguments.
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    send "run\n"
    expect {
	-re "The program .* has been started already.* \[(\]+y or n\[)\]+ $" {
	    send "y\n"
	    exp_continue
	}
	-re ".* call1a \[(\]+uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "run to call1a" ; return }
	timeout { fail "(timeout) run to call1a" ; return }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    send "print uc\n"
    expect {
	-re ".* = 98 'b'\r\n$prompt $" {}
	-re "$prompt $" { fail "print uc" ; return }
	timeout { fail "(timeout) print uc" ; return }
    }
    send "print us\n"
    expect {
	-re ".* = 6\r\n$prompt $" {}
	-re "$prompt $" { fail "print us" ; return }
	timeout { fail "(timeout) print us" ; return }
    }
    send "print ui\n"
    expect {
	-re ".* = 7\r\n$prompt $" {}
	-re "$prompt $" { fail "print ui" ; return }
	timeout { fail "(timeout) print ui" ; return }
    }
    send "print ul\n"
    expect {
	-re ".* = 8\r\n$prompt $" {}
	-re "$prompt $" { fail "print ul" ; return }
	timeout { fail "(timeout) print ul" ; return }
    }
    
    # Continue; should stop at call1b and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call1b \[(\]+us=6, ui=7, ul=8, uc=98 'b'\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call1b" ; return }
	timeout { fail "(timeout) continue to call1b" ; return }
    }

    # Continue; should stop at call1c and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call1c \[(\]+ui=7, ul=8, uc=98 'b', us=6\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call1c" ; return }
	timeout { fail "(timeout) continue to call1c" ; return }
    }

    # Continue; should stop at call1d and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call1d \[(\]+ul=8, uc=98 'b', us=6, ui=7\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call1d" ; return }
	timeout { fail "(timeout) continue to call1d" ; return }
    }

    # Continue; should stop at call1e and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call1e \[(\]+uc1=98 'b', ul=8, uc2=98 'b', ui=7, uc3=98 'b', us=6, uc4=98 'b', uc5=98 'b'\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call1e" ; return }
	timeout { fail "(timeout) continue to call1e" ; return }
    }

    pass "locate actual args, unsigned integral types"
}

#
# Locate actual args; integrals mixed with floating point.
#

proc float_and_integral_args {} {
    global prompt
    global det_file

    delete_breakpoints

    send "break call2a\n" ; expect -re ".*$prompt $"
    send "break call2b\n" ; expect -re ".*$prompt $"
    send "break call2c\n" ; expect -re ".*$prompt $"
    send "break call2d\n" ; expect -re ".*$prompt $"
    send "break call2e\n" ; expect -re ".*$prompt $"
    send "break call2f\n" ; expect -re ".*$prompt $"
    send "break call2g\n" ; expect -re ".*$prompt $"
    send "break call2h\n" ; expect -re ".*$prompt $"
    send "break call2i\n" ; expect -re ".*$prompt $"

    # Run; should stop at call2a and print actual arguments.

    setup_xfail "i960-*-*" 1813
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    send "run\n"
    expect {
	-re "The program .* has been started already.* \[(\]+y or n\[)\]+ $" {
	    send "y\n"
	    exp_continue
	}
	-re ".* call2a \[(\]+c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "run to call2a" ; return }
	timeout { fail "(timeout) run to call2a" ; return }
    }

    # Print each arg as a double check to see if we can print

    send "print c\n"
    expect {
	-re ".* = 97 'a'\r\n$prompt $" {}
	-re "$prompt $" { fail "print c" ; return }
	timeout { fail "(timeout) print c" ; return }
    }
    send "print f1\n"
    expect {
	-re ".* = 4\r\n$prompt $" {}
	-re "$prompt $" { fail "print f1" ; return }
	timeout { fail "(timeout) print f1" ; return }
    }
    send "print s\n"
    expect {
	-re ".* = 1\r\n$prompt $" {}
	-re "$prompt $" { fail "print s" ; return }
	timeout { fail "(timeout) print s" ; return }
    }
    send "print d1\n"
    expect {
	-re ".* = 5\r\n$prompt $" {}
	-re "$prompt $" { fail "print d1" ; return }
	timeout { fail "(timeout) print d1" ; return }
    }
    send "print i\n"
    expect {
	-re ".* = 2\r\n$prompt $" {}
	-re "$prompt $" { fail "print i" ; return }
	timeout { fail "(timeout) print i" ; return }
    }
    send "print f2\n"
    expect {
	-re ".* = 4\r\n$prompt $" {}
	-re "$prompt $" { fail "print f2" ; return }
	timeout { fail "(timeout) print f2" ; return }
    }
    send "print l\n"
    expect {
	-re ".* = 3\r\n$prompt $" {}
	-re "$prompt $" { fail "print l" ; return }
	timeout { fail "(timeout) print l" ; return }
    }
    send "print d2\n"
    expect {
	-re ".* = 5\r\n$prompt $" {}
	-re "$prompt $" { fail "print d2" ; return }
	timeout { fail "(timeout) print d2" ; return }
    }

    # Continue; should stop at call2b and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call2b \[(\]+f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5, c=97 'a'\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call2b" ; return }
	timeout { fail "(timeout) continue to call2b" ; return }
    }

    # Continue; should stop at call2c and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call2c \[(\]+s=1, d1=5, i=2, f2=4, l=3, d2=5, c=97 'a', f1=4\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call2c" ; return }
	timeout { fail "(timeout) continue to call2c" ; return }
    }

    # Continue; should stop at call2d and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call2d \[(\]+d1=5, i=2, f2=4, l=3, d2=5, c=97 'a', f1=4, s=1\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call2d" ; return }
	timeout { fail "(timeout) continue to call2d" ; return }
    }

    # Continue; should stop at call2e and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call2e \[(\]+i=2, f2=4, l=3, d2=5, c=97 'a', f1=4, s=1, d1=5\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call2e" ; return }
	timeout { fail "(timeout) continue to call2e" ; return }
    }

    # Continue; should stop at call2f and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call2f \[(\]+f2=4, l=3, d2=5, c=97 'a', f1=4, s=1, d1=5, i=2\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call2f" ; return }
	timeout { fail "(timeout) continue to call2f" ; return }
    }

    # Continue; should stop at call2g and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call2g \[(\]+l=3, d2=5, c=97 'a', f1=4, s=1, d1=5, i=2, f2=4\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call2g" ; return }
	timeout { fail "(timeout) continue to call2g" ; return }
    }

    # Continue; should stop at call2h and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call2h \[(\]+d2=5, c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call2h" ; return }
	timeout { fail "(timeout) continue to call2h" ; return }
    }

    # Continue; should stop at call2i and print actual arguments.

    send "cont\n"
    expect {
	-re ".* call2i \[(\]+c1=97 'a', f1=4, c2=97 'a', c3=97 'a', d1=5, c4=97 'a', c5=97 'a', c6=97 'a', f2=4, s=1, c7=97 'a', d2=5\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call2i" ; return }
	timeout { fail "(timeout) continue to call2i" ; return }
    }

    pass "locate actual args, mixed integral and float types"
}

#
# Locate actual args; dereference pointers to ints and floats.
#

proc pointer_args {} {
    global prompt
    global hex
    global det_file

    delete_breakpoints

    send "break call3a\n" ; expect -re ".*$prompt $"
    send "break call3b\n" ; expect -re ".*$prompt $"
    send "break call3c\n" ; expect -re ".*$prompt $"

    # Run; should stop at call3a and print actual arguments.
    # Try dereferencing the arguments.

    send "run\n"
    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    expect {
	-re "The program .* has been started already.* \[(\]+y or n\[)\]+ $" {
	    send "y\n"
	    exp_continue
	}
	-re ".* call3a \[(\]+cp=$hex \"a\", sp=$hex, ip=$hex, lp=$hex\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "run to call3a" ; return }
	timeout { fail "(timeout) run to call3a" ; return }
    }

    send "print *cp\n"
    expect {
	-re ".* = 97 'a'\r\n$prompt $" {}
	-re "$prompt $" { fail "print *cp" ; return }
	timeout { fail "(timeout) print *cp" ; return }
    }
    send "print *sp\n"
    expect {
	-re ".* = 1\r\n$prompt $" {}
	-re "$prompt $" { fail "print *sp" ; return }
	timeout { fail "(timeout) print *sp" ; return }
    }
    send "print *ip\n"
    expect {
	-re ".* = 2\r\n$prompt $" {}
	-re "$prompt $" { fail "print *ip" ; return }
	timeout { fail "(timeout) print *ip" ; return }
    }
    send "print *lp\n"
    expect {
	-re ".* = 3\r\n$prompt $" {}
	-re "$prompt $" { fail "print *lp" ; return }
	timeout { fail "(timeout) print *lp" ; return }
    }

    # Continue; should stop at call3b and print actual arguments.
    # Try dereferencing the arguments.

    send "cont\n"
    expect {
	-re ".* call3b \[(\]+ucp=$hex \"b\", usp=$hex, uip=$hex, ulp=$hex\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call3b" ; return }
	timeout { fail "(timeout) continue to call3b" ; return }
    }

    send "print *ucp\n"
    expect {
	-re ".* = 98 'b'\r\n$prompt $" {}
	-re "$prompt $" { fail "print *ucp" ; return }
	timeout { fail "(timeout) print *ucp" ; return }
    }
    send "print *usp\n"
    expect {
	-re ".* = 6\r\n$prompt $" {}
	-re "$prompt $" { fail "print *usp" ; return }
	timeout { fail "(timeout) print *usp" ; return }
    }
    send "print *uip\n"
    expect {
	-re ".* = 7\r\n$prompt $" {}
	-re "$prompt $" { fail "print *uip" ; return }
	timeout { fail "(timeout) print *uip" ; return }
    }
    send "print *ulp\n"
    expect {
	-re ".* = 8\r\n$prompt $" {}
	-re "$prompt $" { fail "print *ulp" ; return }
	timeout { fail "(timeout) print *ulp" ; return }
    }

    # Continue; should stop at call3c and print actual arguments.
    # Try dereferencing the arguments.

    send "cont\n"
    expect {
	-re ".* call3c \[(\]+fp=$hex, dp=$hex\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call3c" ; return }
	timeout { fail "(timeout) continue to call3c" ; return }
    }

    send "print *fp\n"
    expect {
	-re ".* = 4\r\n$prompt $" {}
	-re "$prompt $" { fail "print *fp" ; return }
	timeout { fail "(timeout) print *fp" ; return }
    }
    send "print *dp\n"
    expect {
	-re ".* = 5\r\n$prompt $" {}
	-re "$prompt $" { fail "print *dp" ; return }
	timeout { fail "(timeout) print *dp" ; return }
    }

    pass "locate actual args, pointer types"
}

#
# Locate actual args; structures and unions passed by reference.
#

proc structs_by_reference {} {
    global prompt
    global hex
    global det_file

    delete_breakpoints

    send "break call4a\n" ; expect -re ".*$prompt $"
    send "break call4b\n" ; expect -re ".*$prompt $"

    # Run; should stop at call4a and print actual arguments.
    # Try dereferencing the arguments.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    send "run\n"
    expect {
	-re "The program .* has been started already.* \[(\]+y or n\[)\]+ $" {
	    send "y\n"
	    exp_continue
	}
	-re ".* call4a \[(\]+stp=$hex\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "run to call4a" ; return }
	timeout { fail "(timeout) run to call4a" ; return }
    }

    send "print *stp\n"
    expect {
	-re ".* = \{s1 = 101, s2 = 102\}\r\n$prompt $" {}
	-re "$prompt $" { fail "print *stp" ; return }
	timeout { fail "(timeout) print *stp" ; return }
    }

    # Continue; should stop at call4b and print actual arguments.
    # Try dereferencing the arguments.

    send "cont\n"
    expect {
	-re ".* call4b \[(\]+unp=$hex\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call4b" ; return }
	timeout { fail "(timeout) continue to call4b" ; return }
    }

    send "print *unp\n"
    expect {
	-re ".* = \{u1 = 1, u2 = 1\}\r\n$prompt $" {}
	-re "$prompt $" { fail "print *unp" ; return }
	timeout { fail "(timeout) print *unp" ; return }
    }

    pass "locate actual args, structs/unions passed by reference"
}

#
# Locate actual args; structures and unions passed by value.
#

proc structs_by_value {} {
    global prompt
    global hex
    global det_file

    delete_breakpoints

    send "break call5a\n" ; expect -re ".*$prompt $"
    send "break call5b\n" ; expect -re ".*$prompt $"

    # Run; should stop at call5a and print actual arguments.
    # Try dereferencing the arguments.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    send "run\n"
    expect {
	-re "The program .* has been started already.* \[(\]+y or n\[)\]+ $" {
	    send "y\n"
	    exp_continue
	}
	-re ".* call5a \[(\]+st=\{s1 = 101, s2 = 102\}\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "run to call5a" ; return }
	timeout { fail "(timeout) run to call5a" ; return }
    }

    send "print st\n"
    expect {
	-re ".* = \{s1 = 101, s2 = 102\}\r\n$prompt $" {}
	-re "$prompt $" { fail "print st" ; return }
	timeout { fail "(timeout) print st" ; return }
    }

    # Continue; should stop at call5b and print actual arguments.
    # Try dereferencing the arguments.

    send "cont\n"
    expect {
	-re ".* call5b \[(\]+un=\{u1 = 2, u2 = 2\}\[)\]+ .*$prompt $" {}
	-re "$prompt $" { fail "continue to call5b" ; return }
	timeout { fail "(timeout) continue to call5b" ; return }
    }

    send "print un\n"
    expect {
	-re ".* = \{u1 = 2, u2 = 2\}\r\n$prompt $" {}
	-re "$prompt $" { fail "print un" ; return }
	timeout { fail "(timeout) print un" ; return }
    }

    pass "locate actual args, structs/unions passed by value"
}

#
# Locate actual args; discard, shuffle, and call
#

proc discard_and_shuffle {} {
    global prompt
    global hex
    global decimal
    global det_file

    delete_breakpoints

    send "break call6a\n" ; expect -re ".*$prompt $"
    send "break call6b\n" ; expect -re ".*$prompt $"
    send "break call6c\n" ; expect -re ".*$prompt $"
    send "break call6d\n" ; expect -re ".*$prompt $"
    send "break call6e\n" ; expect -re ".*$prompt $"
    send "break call6f\n" ; expect -re ".*$prompt $"
    send "break call6g\n" ; expect -re ".*$prompt $"
    send "break call6h\n" ; expect -re ".*$prompt $"
    send "break call6i\n" ; expect -re ".*$prompt $"
    send "break call6j\n" ; expect -re ".*$prompt $"
    send "break call6k\n" ; expect -re ".*$prompt $"

    # Run; should stop at call6a and print actual arguments.
    # Print backtrace.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    send "run\n"
    expect {
	-re "The program .* has been started already.* \[(\]+y or n\[)\]+ $" {
	    send "y\n"
	    exp_continue
	}
	-re ".*Breakpoint $decimal, call6a .*$prompt $" {}
	-re "$prompt $" { fail "run to call6a" ; return }
	timeout { fail "(timeout) run to call6a" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call6a \[(\]+c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call6a" ; return }
	timeout { fail "(timeout) backtrace from call6a" ; return }
    }

    # Continue; should stop at call6b and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6b .*$prompt $" {}
	-re "$prompt $" { fail "continue to call6b" ; return }
	timeout { fail "(timeout) continue to call6b" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call6b \[(\]+s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6a \[(\]+c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call6b" ; return }
	timeout { fail "(timeout) backtrace from call6b" ; return }
    }

    # Continue; should stop at call6c and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6c .*$prompt $" {}
	-re "$prompt $" { fail "continue to call6c" ; return }
	timeout { fail "(timeout) continue to call6c" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call6c \[(\]+i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6b \[(\]+s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6a \[(\]+c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call6c" ; return }
	timeout { fail "(timeout) backtrace from call6c" ; return }
    }

    # Continue; should stop at call6d and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6d .*$prompt $" {}
	-re "$prompt $" { fail "continue to call6d" ; return }
	timeout { fail "(timeout) continue to call6d" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call6d \[(\]+l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6c \[(\]+i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6b \[(\]+s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6a \[(\]+c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call6d" ; return }
	timeout { fail "(timeout) backtrace from call6d" ; return }
    }

    # Continue; should stop at call6e and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6e .*$prompt $" {}
	-re "$prompt $" { fail "continue to call6e" ; return }
	timeout { fail "(timeout) continue to call6e" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call6e \[(\]+f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6d \[(\]+l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6c \[(\]+i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6b \[(\]+s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6a \[(\]+c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call6e" ; return }
	timeout { fail "(timeout) backtrace from call6e" ; return }
    }

    # Continue; should stop at call6f and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6f .*$prompt $" {}
	-re "$prompt $" { fail "continue to call6f" ; return }
	timeout { fail "(timeout) continue to call6f" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call6f \[(\]+d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6e \[(\]+f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6d \[(\]+l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6c \[(\]+i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6b \[(\]+s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6a \[(\]+c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call6f" ; return }
	timeout { fail "(timeout) backtrace from call6f" ; return }
    }

    # Continue; should stop at call6g and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6g .*$prompt $" {}
	-re "$prompt $" { fail "continue to call6g" ; return }
	timeout { fail "(timeout) continue to call6g" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call6g \[(\]+uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6f \[(\]+d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6e \[(\]+f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6d \[(\]+l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6c \[(\]+i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6b \[(\]+s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6a \[(\]+c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call6g" ; return }
	timeout { fail "(timeout) backtrace from call6g" ; return }
    }

    # Continue; should stop at call6h and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6h .*$prompt $" {}
	-re "$prompt $" { fail "continue to call6h" ; return }
	timeout { fail "(timeout) continue to call6h" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call6h \[(\]+us=6, ui=7, ul=8\[)\]+ .*\r
.* call6g \[(\]+uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6f \[(\]+d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6e \[(\]+f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6d \[(\]+l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6c \[(\]+i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6b \[(\]+s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6a \[(\]+c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call6h" ; return }
	timeout { fail "(timeout) backtrace from call6h" ; return }
    }

    # Continue; should stop at call6i and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6i .*$prompt $" {}
	-re "$prompt $" { fail "continue to call6i" ; return }
	timeout { fail "(timeout) continue to call6i" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call6i \[(\]+ui=7, ul=8\[)\]+ .*\r
.* call6h \[(\]+us=6, ui=7, ul=8\[)\]+ .*\r
.* call6g \[(\]+uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6f \[(\]+d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6e \[(\]+f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6d \[(\]+l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6c \[(\]+i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6b \[(\]+s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6a \[(\]+c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call6i" ; return }
	timeout { fail "(timeout) backtrace from call6i" ; return }
    }

    # Continue; should stop at call6j and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6j .*$prompt $" {}
	-re "$prompt $" { fail "continue to call6j" ; return }
	timeout { fail "(timeout) continue to call6j" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call6j \[(\]+ul=8\[)\]+ .*\r
.* call6i \[(\]+ui=7, ul=8\[)\]+ .*\r
.* call6h \[(\]+us=6, ui=7, ul=8\[)\]+ .*\r
.* call6g \[(\]+uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6f \[(\]+d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6e \[(\]+f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6d \[(\]+l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6c \[(\]+i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6b \[(\]+s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6a \[(\]+c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call6j" ; return }
	timeout { fail "(timeout) backtrace from call6j" ; return }
    }

    # Continue; should stop at call6k and print actual arguments.
    # Print backtrace.
    # This fails on i960-*-vxworks because gdb gets confused by
    # breakpoints on adjacent instructions.
    setup_xfail "i960-*-vxworks" 1786
    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call6k .*$prompt $" {}
	-re "$prompt $" { fail "continue to call6k"; return }
	timeout { fail "(timeout) continue to call6k"; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call6k \[(\]+\[)\]+ .*\r
.* call6j \[(\]+ul=8\[)\]+ .*\r
.* call6i \[(\]+ui=7, ul=8\[)\]+ .*\r
.* call6h \[(\]+us=6, ui=7, ul=8\[)\]+ .*\r
.* call6g \[(\]+uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6f \[(\]+d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6e \[(\]+f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6d \[(\]+l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6c \[(\]+i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6b \[(\]+s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* call6a \[(\]+c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call6k" ; return }
	timeout { fail "(timeout) backtrace from call6k" ; return }
    }

    pass "locate actual args, discard, shuffle, and call"
}

#
# Locate actual args; shuffle round robin and call
#

proc shuffle_round_robin {} {
    global prompt
    global hex
    global decimal
    global det_file

    delete_breakpoints

    send "break call7a\n" ; expect -re ".*$prompt $"
    send "break call7b\n" ; expect -re ".*$prompt $"
    send "break call7c\n" ; expect -re ".*$prompt $"
    send "break call7d\n" ; expect -re ".*$prompt $"
    send "break call7e\n" ; expect -re ".*$prompt $"
    send "break call7f\n" ; expect -re ".*$prompt $"
    send "break call7g\n" ; expect -re ".*$prompt $"
    send "break call7h\n" ; expect -re ".*$prompt $"
    send "break call7i\n" ; expect -re ".*$prompt $"
    send "break call7j\n" ; expect -re ".*$prompt $"
    send "break call7k\n" ; expect -re ".*$prompt $"

    # Run; should stop at call7a and print actual arguments.
    # Print backtrace.

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    send "run\n"
    expect {
	-re "The program .* has been started already.* \[(\]+y or n\[)\]+ $" {
	    send "y\n"
	    exp_continue
	}
	-re ".*Breakpoint $decimal, call7a .*$prompt $" {}
	-re "$prompt $" { fail "run to call7a" ; return }
	timeout { fail "(timeout) run to call7a" ; return }
    }

    setup_xfail "i960-*-*" 1813
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call7a \[(\]+c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call7a" ; return }
	timeout { fail "(timeout) backtrace from call7a" ; return }
    }

    # Continue; should stop at call7b and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7b .*$prompt $" {}
	-re "$prompt $" { fail "continue to call7b" ; return }
	timeout { fail "(timeout) continue to call7b" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call7b \[(\]+i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\[)\]+ .*\r
.* call7a \[(\]+c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call7b" ; return }
	timeout { fail "(timeout) backtrace from call7b" ; return }
    }

    # Continue; should stop at call7c and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7c .*$prompt $" {}
	-re "$prompt $" { fail "continue to call7c" ; return }
	timeout { fail "(timeout) continue to call7c" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call7c \[(\]+s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\[)\]+ .*\r
.* call7b \[(\]+i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\[)\]+ .*\r
.* call7a \[(\]+c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call7c" ; return }
	timeout { fail "(timeout) backtrace from call7c" ; return }
    }

    # Continue; should stop at call7d and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7d .*$prompt $" {}
	-re "$prompt $" { fail "continue to call7d" ; return }
	timeout { fail "(timeout) continue to call7d" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call7d \[(\]+l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\[)\]+ .*\r
.* call7c \[(\]+s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\[)\]+ .*\r
.* call7b \[(\]+i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\[)\]+ .*\r
.* call7a \[(\]+c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call7d" ; return }
	timeout { fail "(timeout) backtrace from call7d" ; return }
    }

    # Continue; should stop at call7e and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re "Breakpoint $decimal, call7e .*$prompt $" {}
	-re "$prompt $" { fail "continue to call7e" ; return }
	timeout { fail "(timeout) continue to call7e" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call7e \[(\]+f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\[)\]+ .*\r
.* call7d \[(\]+l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\[)\]+ .*\r
.* call7c \[(\]+s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\[)\]+ .*\r
.* call7b \[(\]+i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\[)\]+ .*\r
.* call7a \[(\]+c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call7e" ; return }
	timeout { fail "(timeout) backtrace from call7e" ; return }
    }

    # Continue; should stop at call7f and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7f .*$prompt $" {}
	-re "$prompt $" { fail "continue to call7f" ; return }
	timeout { fail "(timeout) continue to call7f" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call7f \[(\]+uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\[)\]+ .*\r
.* call7e \[(\]+f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\[)\]+ .*\r
.* call7d \[(\]+l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\[)\]+ .*\r
.* call7c \[(\]+s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\[)\]+ .*\r
.* call7b \[(\]+i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\[)\]+ .*\r
.* call7a \[(\]+c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call7f" ; return }
	timeout { fail "(timeout) backtrace from call7f" ; return }
    }

    # Continue; should stop at call7g and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7g .*$prompt $" {}
	-re "$prompt $" { fail "continue to call7g" ; return }
	timeout { fail "(timeout) continue to call7g" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call7g \[(\]+d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\[)\]+ .*\r
.* call7f \[(\]+uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\[)\]+ .*\r
.* call7e \[(\]+f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\[)\]+ .*\r
.* call7d \[(\]+l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\[)\]+ .*\r
.* call7c \[(\]+s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\[)\]+ .*\r
.* call7b \[(\]+i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\[)\]+ .*\r
.* call7a \[(\]+c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call7g" ; return }
	timeout { fail "(timeout) backtrace from call7g" ; return }
    }

    # Continue; should stop at call7h and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7h .*$prompt $" {}
	-re "$prompt $" { fail "continue to call7h" ; return }
	timeout { fail "(timeout) continue to call7h" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call7h \[(\]+us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\[)\]+ .*\r
.* call7g \[(\]+d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\[)\]+ .*\r
.* call7f \[(\]+uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\[)\]+ .*\r
.* call7e \[(\]+f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\[)\]+ .*\r
.* call7d \[(\]+l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\[)\]+ .*\r
.* call7c \[(\]+s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\[)\]+ .*\r
.* call7b \[(\]+i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\[)\]+ .*\r
.* call7a \[(\]+c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call7h" ; return }
	timeout { fail "(timeout) backtrace from call7h" ; return }
    }

    # Continue; should stop at call7i and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7i .*$prompt $" {}
	-re "$prompt $" { fail "continue to call7i" ; return }
	timeout { fail "(timeout) continue to call7i" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call7i \[(\]+ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\[)\]+ .*\r
.* call7h \[(\]+us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\[)\]+ .*\r
.* call7g \[(\]+d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\[)\]+ .*\r
.* call7f \[(\]+uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\[)\]+ .*\r
.* call7e \[(\]+f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\[)\]+ .*\r
.* call7d \[(\]+l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\[)\]+ .*\r
.* call7c \[(\]+s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\[)\]+ .*\r
.* call7b \[(\]+i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\[)\]+ .*\r
.* call7a \[(\]+c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call7i" ; return }
	timeout { fail "(timeout) backtrace from call7i" ; return }
    }

    # Continue; should stop at call7j and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7j .*$prompt $" {}
	-re "$prompt $" { fail "continue to call7j" ; return }
	timeout { fail "(timeout) continue to call7j" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call7j \[(\]+ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\[)\]+ .*\r
.* call7i \[(\]+ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\[)\]+ .*\r
.* call7h \[(\]+us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\[)\]+ .*\r
.* call7g \[(\]+d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\[)\]+ .*\r
.* call7f \[(\]+uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\[)\]+ .*\r
.* call7e \[(\]+f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\[)\]+ .*\r
.* call7d \[(\]+l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\[)\]+ .*\r
.* call7c \[(\]+s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\[)\]+ .*\r
.* call7b \[(\]+i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\[)\]+ .*\r
.* call7a \[(\]+c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call7j" ; return }
	timeout { fail "(timeout) backtrace from call7j" ; return }
    }

    # Continue; should stop at call7k and print actual arguments.
    # Print backtrace.

    send "continue\n"
    expect {
	-re ".*Breakpoint $decimal, call7k .*$prompt $" {}
	-re "$prompt $" { fail "continue to call7k" ; return }
	timeout { fail "(timeout) continue to call7k" ; return }
    }

    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* call7k \[(\]+c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\[)\]+ .*\r
.* call7j \[(\]+ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\[)\]+ .*\r
.* call7i \[(\]+ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\[)\]+ .*\r
.* call7h \[(\]+us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\[)\]+ .*\r
.* call7g \[(\]+d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\[)\]+ .*\r
.* call7f \[(\]+uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\[)\]+ .*\r
.* call7e \[(\]+f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\[)\]+ .*\r
.* call7d \[(\]+l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\[)\]+ .*\r
.* call7c \[(\]+s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\[)\]+ .*\r
.* call7b \[(\]+i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\[)\]+ .*\r
.* call7a \[(\]+c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "backtrace from call7k" ; return }
	timeout { fail "(timeout) backtrace from call7k" ; return }
    }

    pass "locate actual args, shuffle round robin and call"
}

#
# Locate actual args; recursive passing of structs by value
#

proc recursive_structs_by_value {} {
    global prompt
    global hex
    global decimal
    global det_file

    delete_breakpoints

    send "break hitbottom\n" ; expect -re ".*$prompt $"

    # Run; should stop at hitbottom and print actual arguments.
    # Print backtrace.

    send "run\n"
    expect {
	-re "The program .* has been started already.* \[(\]+y or n\[)\]+ $" {
	    send "y\n"
	    exp_continue
	}
	-re ".*Breakpoint $decimal, hitbottom .*$prompt $" {}
	-re "$prompt $" { fail "run to hitbottom" ; return }
	timeout { fail "(timeout) run to hitbottom" ; return }
    }

    # The a29k fails all of these tests, perhaps because the prologue
    # code is broken.
    setup_xfail "a29k-*-udi"
    send "backtrace 100\n"
    expect {
	-re "backtrace 100\r
.* hitbottom \[(\]+\[)\]+ .*\r
.* recurse \[(\]+a=\{s = 0, i = 0, l = 0\}, depth=0\[)\]+ .*\r
.* recurse \[(\]+a=\{s = 1, i = 1, l = 1\}, depth=1\[)\]+ .*\r
.* recurse \[(\]+a=\{s = 2, i = 2, l = 2\}, depth=2\[)\]+ .*\r
.* recurse \[(\]+a=\{s = 3, i = 3, l = 3\}, depth=3\[)\]+ .*\r
.* recurse \[(\]+a=\{s = 4, i = 4, l = 4\}, depth=4\[)\]+ .*\r
.* test_struct_args \[(\]+\[)\]+ .*\r
.* main \[(\]+.*\[)\]+ .*\r
$prompt $" {}
	-re "$prompt $" { fail "recursive passing of structs by value" ; return }
	timeout { fail "(timeout) recursive passing of structs by value" ; return }
    }

    pass "locate actual args, recursive structs by value"
}

proc funcargs_reload { } {
    global objdir
    global subdir
    global binfile
    global srcdir

    if [istarget "mips-idt-*"] then {
	# Restart because IDT/SIM runs out of file descriptors.
	gdb_exit
	gdb_start
	gdb_reinitialize_dir $srcdir/$subdir
	gdb_load $objdir/$subdir/$binfile
    }
}

#
# Test for accessing local stack variables in functions which call alloca
#
proc localvars_after_alloca { } {
    global prompt
    global hex
    global decimal

    if { ! [ runto localvars_after_alloca ] } then { return 0 }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    gdb_test "print c" " = 97 'a'"
    gdb_test "print s" " = 1"
    gdb_test "print i" " = 2"
    gdb_test "print l" " = 3"

    send "next\n"
    expect {
	-re ".*$prompt $" {}
	timeout { fail "next in localvars_after_alloca()" ; return }
    }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    gdb_test "print c" " = 97 'a'"
    gdb_test "print s" " = 1"
    gdb_test "print i" " = 2"
    gdb_test "print l" " = 3"

    gdb_test "backtrace 8" "#0.*localvars_after_alloca \[(\]+c=97 'a', s=1, i=2, l=3\[)\]+.*#1.*main" "backtrace after alloca"
}

#
# Test for accessing local stack variables, backtraces, finish,
# and finally stepping into indirect calls.  The point is that on the PA
# these use a funky `dyncall' mechanism which GDB needs to know about.
#
proc localvars_in_indirect_call { } {
    global prompt
    global hex
    global decimal

    # Can not use "runto call0a" as call0a is called several times
    # during single run.  Instead stop in a marker function and
    # take control from there.
    if { ! [ runto marker_indirect_call ] } then { return 0 }

    # break on the next call to call0a, then delete all the breakpoints
    # and start testing.
    gdb_test "break call0a" "Breakpoint .*"
    gdb_test "continue" "call0a .*"
    delete_breakpoints
    
    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    gdb_test "print c" " = 97 'a'"
    gdb_test "print s" " = 1"
    gdb_test "print i" " = 2"
    gdb_test "print l" " = 3"

    gdb_test "backtrace 8" "#0.*call0a \[(\]+c=97 'a', s=1, i=2, l=3\[)\]+.*#1.*main" "backtrace in indirectly called function"

    # 
    # "finish" brings us back to main.  We then will try to step through
    # the second indirect call.  
    # On some targets (e.g. m68k) gdb will stop from the finish in midline
    # of the first indirect call. This is due to stack adjustment instructions
    # after the indirect call. In these cases we will step till we hit the
    # second indirect call.
    #

    send "finish\n"
    expect {
	-re "\[(\]+\[*\]+pointer_to_call0a\[)\]+ \[(\]+c, s, i, l\[)\]+;.*First.*$prompt $" {
	    send "step\n"
	    exp_continue
	}
	-re "\[(\]+\[*\]+pointer_to_call0a\[)\]+ \[(\]+c, s, i, l\[)\]+;.*Second.*$prompt $" {
	    pass "finish from indirectly called function"
	}
	default { fail "finish from indirectly called function" ; return }
    }

    gdb_test "step" "call0a \[(\]+c=97 'a', s=1, i=2, l=3\[)\]+" \
	"stepping into indirectly called function"
}

# Start with a fresh gdb.
#
# Test for stepping into indirect calls which may have trampolines (possibly
# cascaded) on both the call path and the return path.
# to handle trampolines.
#
proc test_stepping_over_trampolines { } {
    global prompt
    global hex
    global decimal

    # Stop in a marker function and take control from there.
    if { ! [ runto marker_call_with_trampolines ] } then { return 0 }

    # Cater for gdb stopping in midline, see comment for finish above.
    send "finish\n"
    expect {
	-re "marker_call_with_trampolines ..;.*$prompt $" {
	    send "step\n"
	    exp_continue
	}
	-re "pointer_to_call_with_trampolines.*$prompt $" {
	    pass "finish from marker_call_with_trampolines"
	}
	-re ".*$prompt $" {
	    fail "finish from marker_call_with_trampolines"
	}
	default { fail "finish from marker_call_with_trampolines" ; return 0 }
    }

    # Try to step into the target function.
    gdb_test "step" "call_with_trampolines \[(\]+d1=5\[)\]+" \
	"stepping into function called with trampolines"

    # Make we can backtrace and the argument looks correct.  */
    gdb_test "backtrace 8" "#0.*call_with_trampolines \[(\]+d1=5\[)\]+.*1.*main" "backtrace through call with trampolines"

    # Make sure we can get back to main.
    # Stepping back to main might stop again after the return statement
    # or immediately transfer control back to main if optimizations
    # are performed.
    send "step\n"
    expect {
	-re "main .* at.*$prompt $" {
	    pass "stepping back to main from function called with trampolines" ;
	    return 1
	}
	-re "\}.*End of call_with_trampolines.*$prompt $" {
	    send "step\n"
	    exp_continue
	}
	-re ".*$prompt $" {
	    fail "stepping back to main from function called with trampolines"
	}
	default { fail "stepping back to main from function called with trampolines" ; return 0 }
    }
}

# Start with a fresh gdb.

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load $objdir/$subdir/$binfile

set oldtimeout $timeout
set timeout 120

integral_args
funcargs_reload
unsigned_integral_args
funcargs_reload
float_and_integral_args
funcargs_reload
pointer_args
funcargs_reload
structs_by_reference
funcargs_reload
structs_by_value
funcargs_reload
discard_and_shuffle
funcargs_reload
shuffle_round_robin
funcargs_reload
recursive_structs_by_value
funcargs_reload
localvars_after_alloca
funcargs_reload
localvars_in_indirect_call
funcargs_reload
test_stepping_over_trampolines

catch "set timeout $oldtimeout"
