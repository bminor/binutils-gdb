# Copyright 2025 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Check that adding an index to an executable (both a gdb index and a
# dwarf-5 index are tested), doesn't prevent GDB from seeing the
# expected types.

standard_testfile -1.c -2.c -3.c .h

# One of the tests uses this Python file.  The test_* proc checks that
# GDB supports Python tests.  Some of the other procs don't use this
# Python file.
set pyfile [gdb_remote_download host ${srcdir}/${subdir}/${testfile}.py]

if {[build_executable "building" $testfile \
	 [list $srcfile $srcfile2 $srcfile3]] == -1} {
    return
}

# Run 'info types TYPENAME', expect to see an entry from FILENAME for
# the line matching PATTERN.
proc check_info_types { testfile typename filename pattern } {
    with_test_prefix "$filename '$pattern'" {
	clean_restart $testfile

	set line_num [gdb_get_line_number $pattern $filename]
	gdb_test "info types $typename" \
	    "File \[^\r\n\]+/${filename}:(?:\r\n${::decimal}:\[^\r\n\]+)*\r\n${line_num}:\[^\r\n\]+.*"
    }
}

# Start GDB with FILENAME, and examine some of the types.  This proc
# might seem to be using clean_restart a little too much, but we need
# to be really careful here.  As we examine one type, e.g. foo_t, this
# might cause GDB to fully parse a CU, which then means examining
# bar_t gives the expected result.  When, if we'd first looked for
# bar_t, then (due to an index bug) we might not have found the
# correct type definition.
#
# The only way we can be sure that an earlier test isn't going to
# trigger CU expansion is to restart GDB before every query.
proc run_test { filename } {
    # Print all the types for which there is only one representation.
    foreach type { foo_t bar_t baz_t } {
	clean_restart $filename
	gdb_test "ptype $type" \
	    [multi_line \
		 "type = struct $type {" \
		 "\\s+int ${type}_1;" \
		 "\\s+int ${type}_2;" \
		 "}"]
    }

    # There are two different versions of woof_t.  For now, when using
    # `ptype` GDB will just display the first one it finds, which could
    # legitimately be either.
    set woof_int_re [multi_line \
			 "type = struct woof_t {" \
			 "\\s+int woof_t_1;" \
			 "\\s+int woof_t_2;" \
			 "}"]
    set woof_double_re [multi_line \
			    "type = struct woof_t {" \
			    "\\s+double woof_t_3;" \
			    "\\s+double woof_t_4;" \
			    "}"]
    clean_restart $filename
    gdb_test_multiple "ptype woof_t" "" {
	-re -wrap $woof_int_re {
	    pass $gdb_test_name
	}
	-re -wrap $woof_double_re {
	    pass $gdb_test_name
	}
    }

    # Check for declarations and definitions of some types.
    check_info_types $filename foo_t $::srcfile2 "typedef struct foo_t"
    check_info_types $filename foo_t $::srcfile4 "typedef struct foo_t foo_t;"
    check_info_types $filename bar_t $::srcfile3 "typedef struct bar_t"
    check_info_types $filename bar_t $::srcfile4 "typedef struct bar_t bar_t;"
    check_info_types $filename baz_t $::srcfile4 "typedef struct baz_t"
    check_info_types $filename baz_t $::srcfile4 "\} baz_t;"
    check_info_types $filename woof_t $::srcfile2 "typedef struct woof_t"
    check_info_types $filename woof_t $::srcfile3 "typedef struct woof_t"

    # Use Python to look for type symbols.
    if { [allow_python_tests] } {
	foreach_with_prefix type { foo_t bar_t baz_t } {
	    clean_restart $filename
	    gdb_test_no_output "source $::pyfile" "import python scripts"
	    gdb_test "py-show-type $type" \
		[multi_line \
		     "Looking for type '$type':" \
		     "  Found 3 type symbols" \
		     "    1: struct $type \\{ int ${type}_1; int ${type}_2; \\}" \
		     "    2: struct $type \\{ int ${type}_1; int ${type}_2; \\}" \
		     "    3: struct $type \\{ int ${type}_1; int ${type}_2; \\}"]
	}

	clean_restart $filename
	gdb_test_no_output "source $::pyfile" "import python scripts"
	gdb_test "py-show-type woof_t" \
	    [multi_line \
		 "Looking for type 'woof_t':" \
		 "  Found 2 type symbols" \
		 "    1: struct woof_t \\{ (?:int|double) woof_t_(?:1|3); (?:int|double) woof_t_(?:2|4); \\}" \
		 "    2: struct woof_t \\{ (?:int|double) woof_t_(?:1|3); (?:int|double) woof_t_(?:2|4); \\}"]

    }
}

with_test_prefix "no index" {
    run_test $testfile
}

# The previous call to 'run_test' will have left GDB active.  Check if
# BINFILE already has an index.  If it does then we must be running
# with one of the boardfiles that adds an index.  We could possibly
# try to remove the index, but for now, just don't run the following
# parts which rely on adding an index.
set index_type [get_index_type $binfile "check debug style"]
if { $index_type ne "cooked" } {
    unsupported "cannot test without a cooked index"
    return
}

foreach_with_prefix index_type { gdb dwarf5 } {
    set binfile_with_index ${binfile}-idx-${index_type}

    remote_exec build "cp $binfile $binfile_with_index"

    if { $index_type eq "gdb" } {
	set style ""
    } else {
	set style "-dwarf-5"
    }

    if {[ensure_gdb_index $binfile_with_index $style] != 1} {
	unsupported "couldn't add $index_type index"
	return
    }

    run_test [file tail $binfile_with_index]
}
