#   Copyright 2005 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu

if $tracelevel then {
	strace $tracelevel
	}

if { ![isnative] } then {
    continue
}

set prms_id 0
set bug_id 0

set testfile "multi-forks"
set srcfile ${testfile}.c
set binfile ${objdir}/${subdir}/${testfile}

if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
     gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
}

# Until "set follow-fork-mode" and "catch fork" are implemented on
# other targets...
#
if {![istarget "hppa*-hp-hpux*"] && ![istarget "*-pc-linux*"]} then {
    continue
}

# Start with a fresh gdb

gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

global gdb_prompt

# This is a test of gdb's ability to follow the parent, child or both
# parent and child of multiple Unix fork() system calls.
#

# Inferior program calls fork 4 times.  Since each fork
# calls fork 4 times, there will be 16 forks.  Each fork
# saves the return values of its own 4 fork calls.

# First set gdb to follow the child.
# The result should be that each of the 4 forks returns zero.

runto_main
set exit_bp_loc [gdb_get_line_number "Set exit breakpoint here."]
gdb_test "break $exit_bp_loc" "Breakpoint.* at .*" "Break at exit"
gdb_test "set follow child" "" ""

send_gdb "continue\n"
gdb_expect {
    -re ".*Break.* main .*$gdb_prompt $" {}
    -re ".*$gdb_prompt $" {fail "run to exit 1"}
    default {fail "run to exit 1 (timeout)"}
}

gdb_test "print pids" "\\$.* = \\{0, 0, 0, 0\\}.*" "follow child, print pids"

# Now set gdb to follow the parent.
# Result should be that none of the 4 forks returns zero.

delete_breakpoints
runto_main
gdb_test "break $exit_bp_loc" "Breakpoint.* at .*" "Break at exit"
gdb_test "set follow parent" "" ""

send_gdb "continue\n"
gdb_expect {
    -re ".*Break.* main .*$gdb_prompt $" {}
    -re ".*$gdb_prompt $" {fail "run to exit 2"}
    default {fail "run to exit 2 (timeout)"}
}

gdb_test "print pids\[0\]==0 || pids\[1\]==0 || pids\[2\]==0 || pids\[3\]==0" \
    " = 0" "follow parent, print pids"

#
# Now test with detach-on-fork off.
#

runto_main
gdb_test "break $exit_bp_loc" "Breakpoint.* at .*" ""

gdb_test "help set detach-on-fork" "whether gdb will detach the child.*" \
    "help set detach"

gdb_test "show detach-on-fork" "on." "show detach default on"

gdb_test "set detach off" "" "set detach off"

#
# We will now run every fork up to the exit bp, 
# eventually winding up with 16 forks.
#

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 1"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 1"
# FIXME check pids, info fork again
gdb_test "restart 1" "_dl_sysinfo_int80.*" "restart 1"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 2"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 2"
# FIXME check pids, info fork again
gdb_test "restart 2" "_dl_sysinfo_int80.*" "restart 2"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 3"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 3"
# FIXME check pids, info fork again
gdb_test "restart 3" "_dl_sysinfo_int80.*" "restart 3"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 4"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 4"
# FIXME check pids, info fork again
gdb_test "restart 4" "_dl_sysinfo_int80.*" "restart 4"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 5"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 5"
# FIXME check pids, info fork again
gdb_test "restart 5" "_dl_sysinfo_int80.*" "restart 5"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 6"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 6"
# FIXME check pids, info fork again
gdb_test "restart 6" "_dl_sysinfo_int80.*" "restart 6"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 7"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 7"
# FIXME check pids, info fork again
gdb_test "restart 7" "_dl_sysinfo_int80.*" "restart 7"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 8"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 8"
# FIXME check pids, info fork again
gdb_test "restart 8" "_dl_sysinfo_int80.*" "restart 8"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 9"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 9"
# FIXME check pids, info fork again
gdb_test "restart 9" "_dl_sysinfo_int80.*" "restart 9"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 10"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 10"
# FIXME check pids, info fork again
gdb_test "restart 10" "_dl_sysinfo_int80.*" "restart 10"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 11"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 11"
# FIXME check pids, info fork again
gdb_test "restart 11" "_dl_sysinfo_int80.*" "restart 11"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 12"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 12"
# FIXME check pids, info fork again
gdb_test "restart 12" "_dl_sysinfo_int80.*" "restart 12"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 13"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 13"
# FIXME check pids, info fork again
gdb_test "restart 13" "_dl_sysinfo_int80.*" "restart 13"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 14"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 14"
# FIXME check pids, info fork again
gdb_test "restart 14" "_dl_sysinfo_int80.*" "restart 14"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 15"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 15"
# FIXME check pids, info fork again
gdb_test "restart 15" "_dl_sysinfo_int80.*" "restart 15"

gdb_test "continue" "Breakpoint .* main .*exit.*" "Run to exit 16"
gdb_test "info fork" " 4 .* 3 .* 2 .* 1 .*" "info fork 16"
# FIXME check pids, info fork again
gdb_test "restart 0" " main .*" "restart final"

#
# Now we should examine all the pids.
#

# 
# Test detach-fork
# 

# [assumes we're at #0]
gdb_test "detach-fork 1" "Detached .*" "Detach 1"
gdb_test "detach-fork 2" "Detached .*" "Detach 2"
gdb_test "detach-fork 3" "Detached .*" "Detach 3"
gdb_test "detach-fork 4" "Detached .*" "Detach 4"

# 
# Test delete-fork
# 

gdb_test "delete- 5" "" "Delete 5"
gdb_test "delete- 6" "" "Delete 6"
gdb_test "delete- 7" "" "Delete 7"
gdb_test "delete- 8" "" "Delete 8"
gdb_test "delete- 9" "" "Delete 9"
gdb_test "delete- 10" "" "Delete 10"
gdb_test "delete- 11" "" "Delete 11"
gdb_test "delete- 12" "" "Delete 12"
gdb_test "delete- 13" "" "Delete 13"
gdb_test "delete- 14" "" "Delete 14"
gdb_test "delete- 15" "" "Delete 15"



return 0
