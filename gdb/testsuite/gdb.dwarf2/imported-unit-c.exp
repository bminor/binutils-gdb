load_lib dwarf.exp
load_lib gdb-python.exp

# This test can only be run on targets which support DWARF-2 and use gas.
require dwarf2_support

standard_testfile main-foo.c .S

set executable ${testfile}
set asm_file [standard_output_file ${srcfile2}]

# We need to know the size of integer and address types in order
# to write some of the debugging info we'd like to generate.
if {[prepare_for_testing "failed to prepare" ${testfile} ${srcfile} {debug}]} {
    return -1
}

# Create the DWARF.
Dwarf::assemble $asm_file {
    declare_labels cu_label cu2_label int_label int2_label
    set int_size [get_sizeof "int" 4]

    # imported CU 1: inty unsigned
    cu {} {
	cu_label: compile_unit {
	    DW_AT_language @DW_LANG_C
	    DW_AT_name "<artificial>"
	} {
	    int_label: base_type {
		DW_AT_byte_size $int_size sdata
		DW_AT_encoding @DW_ATE_unsigned
		DW_AT_name {unsigned int}
	    }
	    DW_TAG_typedef {
		DW_AT_name inty
		DW_AT_type :$int_label
	    }
	    DW_TAG_typedef {
		DW_AT_name inty_1
		DW_AT_type :$int2_label
	    }
	    DW_TAG_typedef {
		DW_AT_name inty_2
		DW_AT_type :$int2_label
	    }
	    DW_TAG_typedef {
		DW_AT_name inty_3
		DW_AT_type :$int2_label
	    }
	    DW_TAG_typedef {
		DW_AT_name inty_4
		DW_AT_type :$int2_label
	    }
	    DW_TAG_typedef {
		DW_AT_name inty_5
		DW_AT_type :$int2_label
	    }
	}
    }

    # imported CU 2: inty signed
    cu {} {
	cu2_label: compile_unit {
	    DW_AT_language @DW_LANG_C
	    DW_AT_name "<artificial>"
	} {
	    int2_label: base_type {
		DW_AT_byte_size $int_size sdata
		DW_AT_encoding @DW_ATE_signed
		DW_AT_name {int}
	    }
	    DW_TAG_typedef {
		DW_AT_name inty
		DW_AT_type :$int2_label
	    }
	    DW_TAG_typedef {
		DW_AT_name inty_1
		DW_AT_type :$int2_label
	    }
	    DW_TAG_typedef {
		DW_AT_name inty_2
		DW_AT_type :$int2_label
	    }
	    DW_TAG_typedef {
		DW_AT_name inty_3
		DW_AT_type :$int2_label
	    }
	    DW_TAG_typedef {
		DW_AT_name inty_4
		DW_AT_type :$int2_label
	    }
	    DW_TAG_typedef {
		DW_AT_name inty_5
		DW_AT_type :$int2_label
	    }
	}
    }

    # main CU
    cu {} {
	compile_unit {
	    DW_AT_language @DW_LANG_C
	    DW_AT_name "<artificial>"
	} {
	    imported_unit {
		DW_AT_import %$cu2_label
	    }

	    subprogram {
		MACRO_AT_func {main}
		DW_AT_external 1 flag
	    }
	}
    }

    # foo CU
    cu {} {
	compile_unit {
	    DW_AT_language @DW_LANG_C
	    DW_AT_name "<artificial>"
	} {
	    imported_unit {
		DW_AT_import %$cu_label
	    }

	    subprogram {
		MACRO_AT_func {foo}
		DW_AT_external 1 flag
	    }
	}
    }

}

if { [prepare_for_testing "failed to prepare" ${testfile} \
	  [list $srcfile $asm_file] {nodebug}] } {
    return -1
}

# If Python testing is enabled then try printing the global and static
# blocks for the current frame, which is in function FUNC.
proc test_python_block_printing { func } {
    if {![allow_python_tests]} {
	return
    }

    gdb_test "python print(gdb.selected_frame().block().static_block)" \
	[string_to_regexp "<gdb.Block <anonymous> {}>"] \
	"print static block in $func"
    gdb_test "python print(gdb.selected_frame().block().global_block)" \
	[string_to_regexp "<gdb.Block <anonymous> {$func}>"] \
	"print global block in $func"
}

if {![runto_main]} {
    return -1
}

gdb_test "ptype inty" "type = int" "ptype in main"

test_python_block_printing main

gdb_breakpoint "foo"
gdb_continue_to_breakpoint "continue to breakpoint for foo"

gdb_test "ptype inty" "type = unsigned int" "ptype in foo"

test_python_block_printing foo
