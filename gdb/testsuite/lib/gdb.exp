# Copyright (C) 1992 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@cygnus.com)

# Generic gdb subroutines that should work for any target.  If these
# need to be modified for any target, it can be done with a variable
# or by passing arguments.

#
# gdb_unload -- unload a file if one is loaded
#

proc gdb_unload {} {
    global verbose
    global GDB
    global prompt
    send "file\n"
    expect {
	-re "No exec file now\.\r" { continue -expect }
	-re "No symbol file now\.\r" { continue -expect }
	-re "A program is being debugged already..*Kill it\? \(y or n\) $"\
	    { send "y\n"
		if $verbose>1 then {
		    send_user "\t\tKilling previous program being debugged\n"
		}
	    continue -expect
	}
	-re "Discard symbol table from .*\? \(y or n\) $" {
	    send "y\n"
	    continue -expect
	}
	-re "$prompt $" {}
	timeout {
	    error "couldn't unload file in $GDB (timed out)."
	    return -1
	}
    }
}

# Many of the tests depend on setting breakpoints at various places and
# running until that breakpoint is reached.  At times, we want to start
# with a clean-slate with respect to breakpoints, so this utility proc 
# lets us do this without duplicating this code everywhere.
#

proc delete_breakpoints {} {
    global prompt

    send "delete breakpoints\n"
    expect {
	-re "Delete all breakpoints\? \(y or n\) $" {
	    send "y\n"
	    continue -expect
	}
	-re "y\r\n$prompt $" {}
	-re ".*$prompt $" { fail "Delete all breakpoints" ; return }
	timeout { fail "Delete all breakpoints (timeout)" ; return }
    }
    send "info breakpoints\n"
    expect {
	-re "No breakpoints or watchpoints..*$prompt $" {}
	-re ".*$prompt $" { fail "breakpoints not deleted" ; return }
	timeout { fail "info breakpoints (timeout)" ; return }
    }
}


#
# Set breakpoint at function and run gdb until it breaks there.
# Since this is the only breakpoint that will be set, if it stops
# at a breakpoint, we will assume it is the one we want.  We can't
# just compare to "function" because it might be a fully qualified,
# single quoted C++ function specifier.
#

proc runto { function } {
    global prompt
    global decimal

    send "delete\n"
    expect {
	-re "Delete all breakpoints\? \(y or n\) $" {
	    send "y\n"
	    expect {
		-re "$prompt $" {}
		timeout { fail "deleting breakpoints (timeout)" ; return 0 }
	    }
	}
	-re ".*$prompt $" {}
	timeout { fail "deleting breakpoints (timeout)" ; return 0 }
    }

    send "break $function\n"
    # The first regexp is what we get with -g, the second without -g.
    expect {
	-re "Break.* at .*: file .*, line $decimal.\r\n$prompt $" {}
	-re "Breakpoint \[0-9\]* at 0x\[0-9a-f\]*.*$prompt $" {}
	-re "$prompt $" { fail "setting breakpoint at $function" ; return 0 }
	timeout { fail "setting breakpoint at $function (timeout)" ; return 0 }
    }

    send "run\n"
    # the "at foo.c:36" output we get with -g.
    # the "in func" output we get without -g.
    expect {
	-re "The program .* has been started already.* \(y or n\) $" {
	    send "y\n"
	    continue -expect
	}
	-re "Starting.*Break.* at .*:$decimal.*$prompt $" { return 1 }
	-re "Breakpoint \[0-9\]*, \[0-9xa-f\]* in $function.*$prompt $" { 
	    return 1
	}
	-re "$prompt $" { fail "running to $function" ; return 0 }
	timeout { fail "running to $function (timeout)" ; return 0 }
    }
}

#
# gdb_test -- send a command to gdb and test the result.
#             Takes three parameters.
#             Parameters:
#                First one is the command to execute,
#                Second one is the pattern to match for a PASS,
#                Third one is an optional message to be printed. If this
#                  a null string "", then the pass/fail messages are not printed.
#             Returns:
#                1 if the test failed,
#                0 if the test passes,
#               -1 if there was an internal error.
#
proc gdb_test { args } {
    global verbose
    global prompt
    global GDB
    global spawn_id

    if [llength $args]==3 then {
	set message [lindex $args 2]
    } else {
	set message [lindex $args 0]
    }
    set command [lindex $args 0]
    set pattern [lindex $args 1]

    if $verbose>2 then {
	send_user "Sending \"$command\" to gdb\n"
	send_user "Looking to match \"$pattern\"\n"
	send_user "Message is \"$message\"\n"
    }

    set result -1
    set errmess ""
    # trap the send so any problems don't crash things
    catch "send \"$command\n\"" errmess
    if [string match "write\(spawn_id=\[0-9\]+\):" $errmess] then {
	error "sent \"$command\" got expect error \"$errmess\""
	catch "close"
	gdb_start
	return -1
    }

    expect {
	-re ".*Ending remote debugging.*$prompt$" {
	    if ![isnative] then {
		warning "Can`t communicate to remote target."
	    }
	    gdb_exit
	    gdb_start
	    set result -1
	}
	-re "$pattern.*$prompt $" {
	    if ![string match "" $message] then {
		pass "$message"
	    }
	    set result 0
	}
	-re "Undefined command:.*$prompt" {
	    error "Undefined command \"$command\"."
	    set result 1
	}
	-re "Ambiguous command.*$prompt $" {
	    error "\"$command\" is not a unique command name."
	    set result 1
	}
	-re ".*$prompt $" {
	    if ![string match "" $message] then {
		fail "$message"
	    }
	    set result 1
	}
	"<return>" {
	    send "\n"
	    error "Window too small."
	}
	-re "\(y or n\) " {
	    send "n\n"
	    error "Got interactive prompt."
	}
	eof {
	    error "Process no longer exists"
	    return -1
	}
	buffer_full {
	    error "internal buffer is full."
	}
	timeout	{
	    fail "(timeout) $message"
	    set result 1
	}
    }
    return $result
}

proc gdb_reinitialize_dir { subdir } {
    global prompt
    global verbose

    send "dir\n"
    expect {
	-re "Reinitialize source path to empty.*" {
	    send "y\n"
	    expect {
		-re "Source directories searched.*$prompt $" {
		    send "dir $subdir\n"
		    expect {
			-re "Source directories searched.*$prompt $" {
			    if $verbose>1 then {
				send_user "Dir set to $subdir\n"
			    }
			}
			-re ".*$prompt $" {
			    error "Dir \"$subdir\" failed."
			}
		    }
		}
		-re ".*$prompt $" {
		    error "Dir \"$subdir\" failed."
		}
	    }
	}
	-re ".*$prompt $" {
	    error "Dir \"$subdir\" failed."
	}
    }
}


#
# gdb_exit -- exit the GDB, killing the target program if necessary
#
proc default_gdb_exit {} {
    global GDB
    global GDBFLAGS
    global verbose

    verbose "Quitting $GDB $GDBFLAGS" 1

    # This used to be 1 for unix-gdb.exp
    set timeout 5

    catch "send \"quit\n\"" result
    # If the process has gone away (e.g. gdb dumped core), deal with it.
    if [string match "write\(spawn_id=\[0-9\]+\):" $result] then {
	catch "close"
	# FIXME:  Shouldn't we call "wait" too?
	return -1
    }
    # FIXME: What is this catch statement doing here?  Won't it prevent us
    # from getting errors that we'd rather see?
    catch {
    expect {
	eof { 
	    verbose "Got EOF from $GDB" 2
	}
	timeout { 
	    verbose "Got TIMEOUT from $GDB" 2
	}
	-re "The program is running.  Quit anyway.*(y or n) $" {
	    send "y\n"
	    verbose "Killing program being debugged" 2
	}
    }
    }

    # FIXME: Does the catch prevent us from getting errors that we'd rather
    # see?  the old gdb_exit in unix-gdb.exp had "close" without catch
    # in the above expect statement (for the timeout and -re "The
    # program... cases) (as well as a catch "close" here).
    catch "close"

    # Before this was here sometimes "uit" would get sent to the next GDB
    # (assuming this is immediately followed by gdb_start), which would
    # cause a loss of syncronization (i.e. all the stuff that swallows a
    # prompt would swallow the wrong one).
    wait
}




