# Copyright (C) 1992, 1994, 1995 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu

# This file was written by Fred Fish. (fnf@cygnus.com)

# Generic gdb subroutines that should work for any target.  If these
# need to be modified for any target, it can be done with a variable
# or by passing arguments.

global GDB
if ![info exists GDB] then {
    if [file exists $base_dir/../gdb] then {
	set GDB $base_dir/../gdb
    } else {
	set GDB [transform gdb]
    }
}

global GDBFLAGS
if ![info exists GDBFLAGS] then {
    set GDBFLAGS "-nx"
}

# set the prompt if it doesn't exist
global prompt
if ![info exists prompt] then {
    set prompt "\[(\]gdb\[)\]"
}

#
# gdb_version -- extract and print the version number of GDB
#
proc default_gdb_version {} {
    global GDB
    global GDBFLAGS
    if {[which $GDB] != 0} then {
	set tmp [exec echo "q" | $GDB -nw $GDBFLAGS]
	regexp " \[0-9\.\]+" $tmp version
	clone_output "[which $GDB] version$version -nw $GDBFLAGS \n"
    } else {
	warning "$GDB does not exist"
    }
}

#
# gdb_unload -- unload a file if one is loaded
#

proc gdb_unload {} {
    global verbose
    global GDB
    global prompt
    send "file\n"
    expect {
	-re "No exec file now.*\r" { exp_continue }
	-re "No symbol file now.*\r" { exp_continue }
	-re "A program is being debugged already..*Kill it.*y or n. $"\
	    { send "y\n"
		verbose "\t\tKilling previous program being debugged"
	    exp_continue
	}
	-re "Discard symbol table from .*y or n. $" {
	    send "y\n"
	    exp_continue
	}
	-re "$prompt $" {}
	timeout {
	    perror "couldn't unload file in $GDB (timed out)."
	    return -1
	}
    }
}

# Many of the tests depend on setting breakpoints at various places and
# running until that breakpoint is reached.  At times, we want to start
# with a clean-slate with respect to breakpoints, so this utility proc 
# lets us do this without duplicating this code everywhere.
#

proc delete_breakpoints {} {
    global prompt

    send "delete breakpoints\n"
    expect {
	-re "Delete all breakpoints.*y or n. $" {
	    send "y\n"
	    exp_continue
	}
	-re "y\r\n$prompt $" {}
	-re ".*$prompt $" { # This happens if there were no breakpoints
	    }
	timeout { perror "Delete all breakpoints (timeout)" ; return }
    }
    send "info breakpoints\n"
    expect {
	-re "No breakpoints or watchpoints..*$prompt $" {}
	-re ".*$prompt $" { perror "breakpoints not deleted" ; return }
	timeout { perror "info breakpoints (timeout)" ; return }
    }
}


#
# Generic run command.
#
# The second pattern below matches up to the first newline *only*.
# Using ``.*$'' could swallow up output that we attempt to match
# elsewhere.
#
proc gdb_run_cmd {} {
    send "run\n"
    expect {
	-re "The program .* has been started already.*y or n. $" {
	    send "y\n"
	    exp_continue
	}
	-re "Starting program: \[^\n\]*" {}
    }
}


# Set breakpoint at function and run gdb until it breaks there.
# Since this is the only breakpoint that will be set, if it stops
# at a breakpoint, we will assume it is the one we want.  We can't
# just compare to "function" because it might be a fully qualified,
# single quoted C++ function specifier.

proc runto { function } {
    global prompt
    global decimal

    send "delete\n"
    expect {
	-re "delete.*Delete all breakpoints.*y or n. $" {
	    send "y\n"
	    expect {
		-re "$prompt $" {}
		timeout { fail "deleting breakpoints (timeout)" ; return 0 }
	    }
	}
	-re ".*$prompt $" {}
	timeout { fail "deleting breakpoints (timeout)" ; return 0 }
    }

    send "break $function\n"
    # The first two regexps are what we get with -g, the third is without -g.
    expect {
	-re "Breakpoint \[0-9\]* at .*: file .*, line $decimal.\r\n$prompt $" {}
	-re "Breakpoint \[0-9\]*: file .*, line $decimal.\r\n$prompt $" {}
	-re "Breakpoint \[0-9\]* at .*$prompt $" {}
	-re "$prompt $" { fail "setting breakpoint at $function" ; return 0 }
	timeout { fail "setting breakpoint at $function (timeout)" ; return 0 }
    }

    gdb_run_cmd
    
    # the "at foo.c:36" output we get with -g.
    # the "in func" output we get without -g.
    expect {
	-re "Break.* at .*:$decimal.*$prompt $" {
	    return 1
	}
	-re "Breakpoint \[0-9\]*, \[0-9xa-f\]* in $function.*$prompt $" { 
	    return 1
	}
	-re "$prompt $" { 
	    fail "running to $function"
	    return 0
	}
	timeout { 
	    fail "running to $function (timeout)"
	    return 0
	}
    }
}

#
# gdb_test -- send a command to gdb and test the result.
#             Takes three parameters.
#             Parameters:
#                First one is the command to execute,
#                Second one is the pattern to match for a PASS,
#                Third one is an optional message to be printed. If this
#                  a null string "", then the pass/fail messages are not printed.
#             Returns:
#                1 if the test failed,
#                0 if the test passes,
#               -1 if there was an internal error.
#
proc gdb_test { args } {
    global verbose
    global prompt
    global GDB
    global spawn_id

    if [llength $args]==3 then {
	set message [lindex $args 2]
    } else {
	set message [lindex $args 0]
    }
    set command [lindex $args 0]
    set pattern [lindex $args 1]

    if $verbose>2 then {
	send_user "Sending \"$command\" to gdb\n"
	send_user "Looking to match \"$pattern\"\n"
	send_user "Message is \"$message\"\n"
    }

    set result -1
    if ![string match $command ""] {
	send "$command\n"
    }

    expect {
	-re ".*Ending remote debugging.*$prompt$" {
	    if ![isnative] then {
		warning "Can`t communicate to remote target."
	    }
	    gdb_exit
	    gdb_start
	    set result -1
	}
	-re "$pattern\r\n$prompt $" {
	    if ![string match "" $message] then {
		pass "$message"
	    }
	    set result 0
	}
	-re "Undefined command:.*$prompt" {
	    perror "Undefined command \"$command\"."
	    set result 1
	}
	-re "Ambiguous command.*$prompt $" {
	    perror "\"$command\" is not a unique command name."
	    set result 1
	}
	-re ".*$prompt $" {
	    if ![string match "" $message] then {
		fail "$message"
	    }
	    set result 1
	}
	"<return>" {
	    send "\n"
	    perror "Window too small."
	}
	-re "\[(\]+y or n\[)\]+ " {
	    send "n\n"
	    perror "Got interactive prompt."
	}
	eof {
	    perror "Process no longer exists"
	    return -1
	}
	buffer_full {
	    perror "internal buffer is full."
	}
	timeout	{
	    if ![string match "" $message] then {
		fail "(timeout) $message"
	    }
	    set result 1
	}
    }
    return $result
}

# Testing printing of a specific value.  For passes and fails, return
# a 1 to indicate that more tests can proceed.  However a timeout
# is a serious error, generates a special fail message, and causes
# a 0 to be returned to indicate that more tests are likely to fail
# as well.
#
# Args are:
#
#	First one is string to send to gdb
#	Second one is string to match gdb result to
#	Third one is an optional message to be printed
#
# This differs from gdb_test in a few ways: (1) handling of empty
# sendthis (I suspect test_print_accept callers never use this), (2)
# it tests for the " =" (that could easily be moved to the callers.

proc test_print_accept { args } {
    global prompt
    global verbose

    if [llength $args]==3 then {
	set message [lindex $args 2]
    } else {
	set message [lindex $args 0]
    }
    set sendthis [lindex $args 0]
    set expectthis [lindex $args 1]
    if $verbose>2 then {
	send_user "Sending \"$sendthis\" to gdb\n"
	send_user "Looking to match \"$expectthis\"\n"
	send_user "Message is \"$message\"\n"
    }
    send "$sendthis\n"
    expect {
	-re ".* = $expectthis\r\n$prompt $" {
	    if ![string match "" $message] then {
		pass "$sendthis ($message)"
	    } else {
		pass "$sendthis"
	    }
	    return 1
	}
	-re ".*$prompt $" {
	    if ![string match "" $message] then {
		fail "$sendthis ($message)"
	    } else {
		fail "$sendthis"
	    }
	    return 1
	}
	timeout {
	    fail "$sendthis (timeout)"
	    return 0
	}
    }
}

# Testing printing of a specific value.  For pass or fail, return
# a 1 to indicate that more tests can proceed.  However a timeout
# is a serious error, generates a special fail message, and causes
# a 0 to be returned to indicate that more tests are likely to fail
# as well.

proc test_print_reject { args } {
    global prompt
    global verbose

    if [llength $args]==2 then {
	set expectthis [lindex $args 1]
    } else {
	set expectthis "should never match this bogus string"
    }
    set sendthis [lindex $args 0]
    if $verbose>2 then {
	send_user "Sending \"$sendthis\" to gdb\n"
	send_user "Looking to match \"$expectthis\"\n"
    }
    send "$sendthis\n"
    expect {
	-re ".*A .* in expression.*\\.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*Invalid syntax in expression.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*Junk after end of expression.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*Invalid number.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*Invalid character constant.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*No symbol table is loaded.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*No symbol .* in current context.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*$expectthis.*$prompt $" {
	    pass "reject $sendthis"
	    return 1
	}
	-re ".*$prompt $" {
	    fail "reject $sendthis"
	    return 1
	}
	default {
	    fail "reject $sendthis (eof or timeout)"
	    return 0
	}
    }
}

# Given an input string, adds backslashes as needed to create a
# regexp that will match the string.

proc string_to_regexp {str} {
    set result $str
    regsub -all {[]*+.|()^$\[]} $str {\\&} result
    return $result
}

# Same as gdb_test, but the second parameter is not a regexp,
# but a string that must match exactly.

proc gdb_test_exact { args } {
    set command [lindex $args 0]
    set pattern [string_to_regexp [lindex $args 1]]
    if [llength $args]==3 then {
	set message [lindex $args 2]
    } else {
	set message $command
    }
    return [gdb_test $command $pattern $message]
}

proc gdb_reinitialize_dir { subdir } {
    global prompt

   send "dir\n"
    expect {
	-re "Reinitialize source path to empty.*" {
	    send "y\n"
	    expect {
		-re "Source directories searched.*$prompt $" {
		    send "dir $subdir\n"
		    expect {
			-re "Source directories searched.*$prompt $" {
			    verbose "Dir set to $subdir"
			}
			-re ".*$prompt $" {
			    perror "Dir \"$subdir\" failed."
			}
		    }
		}
		-re ".*$prompt $" {
		    perror "Dir \"$subdir\" failed."
		}
	    }
	}
	-re ".*$prompt $" {
	    perror "Dir \"$subdir\" failed."
	}
    }
}

#
# gdb_exit -- exit the GDB, killing the target program if necessary
#
proc default_gdb_exit {} {
    global GDB
    global GDBFLAGS
    global verbose

    verbose "Quitting $GDB $GDBFLAGS"

    # This used to be 1 for unix-gdb.exp
    set timeout 5

    # We used to try to send "quit" to GDB, and wait for it to die.
    # Dealing with all the cases and errors got pretty hairy.  Just close it, 
    # that is simpler.
    close

    # Omitting this probably would cause strange timing-dependent failures.
    wait
}

#
# gdb_load -- load a file into the debugger.
#             return a -1 if anything goes wrong.
#
proc gdb_file_cmd { arg } {
    global verbose
    global loadpath
    global loadfile
    global GDB
    global prompt
    global spawn_id

    send "file $arg\n"
    expect {
        -re "Reading symbols from.*done.*$prompt $" {
            verbose "\t\tLoaded $arg into the $GDB"
            return 0
        }
        -re "has no symbol-table.*$prompt $" {
            perror "$arg wasn't compiled with \"-g\""
            return -1
        }
        -re "A program is being debugged already.*Kill it.*y or n. $" {
            send "y\n"
                verbose "\t\tKilling previous program being debugged"
            exp_continue
        }
        -re "Load new symbol table from \".*\".*y or n. $" {
            send "y\n"
            expect {
                -re "Reading symbols from.*done.*$prompt $" {
                    verbose "\t\tLoaded $arg with new symbol table into $GDB"
                    return 0
                }
                timeout {
                    perror "(timeout) Couldn't load $arg, other program already l
oaded."
                    return -1
                }
            }
	}
        -re ".*No such file or directory.*$prompt $" {
            perror "($arg) No such file or directory\n"
            return -1
        }
        -re "$prompt $" {
            perror "couldn't load $arg into $GDB."
            return -1
            }
        timeout {
            perror "couldn't load $arg into $GDB (timed out)."
            return -1
        }
        eof {
            # This is an attempt to detect a core dump, but seems not to
            # work.  Perhaps we need to match .* followed by eof, in which
            # expect does not seem to have a way to do that.
            perror "couldn't load $arg into $GDB (end of file)."
            return -1
        }
    }
}

#
# start gdb -- start gdb running, default procedure
#
proc default_gdb_start { } {
    global verbose
    global GDB
    global GDBFLAGS
    global prompt
    global spawn_id
    global timeout
    verbose "Spawning $GDB -nw $GDBFLAGS"

    if { [which $GDB] == 0 } then {
	perror "$GDB does not exist."
	exit 1
    }
    
    set oldtimeout $timeout
    set timeout [expr "$timeout + 60"]
    eval "spawn $GDB -nw $GDBFLAGS"
    expect {
	-re ".*\r\n$prompt $" {
	    verbose "GDB initialized."
	}
	-re "$prompt $"	{
	    perror "GDB never initialized."
	    return -1
	}
	timeout		{
	    perror "(timeout) GDB never initialized."
	    return -1
	}
    }
    set timeout $oldtimeout
    # force the height to "unlimited", so no pagers get used
    send "set height 0\n"
    expect {
	-re ".*$prompt $" { 
	    verbose "Setting height to 0." 2
	}
	timeout {
	    warning "Couldn't set the height to 0."
	}
    }
    # force the width to "unlimited", so no wraparound occurs
    send "set width 0\n"
    expect {
	-re ".*$prompt $" {
	    verbose "Seting width to 0." 2
	}
	timeout {
	    warning "Couldn't set the width to 0."
	}
    }
}

#
# FIXME: this is a copy of the new library procedure, but it's here too
# till the new dejagnu gets installed everywhere. I'd hate to break the
# gdb tests suite.
#
global argv0
if ![info exists argv0] then {
    proc exp_continue { } {
	continue -expect
    }
}

proc skip_chill_tests {} {
    return ![isnative]
}
