# PKE tests for code coverage / functional testing
#
#
# ---- STCYCL/CYCLE ---- [test.code.stcycl]
#
# Test STCYCL instruction
0 0x0100fedc_00000000_00000000_00000000 0x00000000 PPPP
# Attempt erroneous write to CYCLE register
! 0x10003840 0x0000dead
# Read CYCLE register; confirm proper value
? 0x10003840 0x0000fedc 0xffffffff
# Read STAT register; confirm ER1 not set
? 0x10003800 0x00000000 0x00002000
#
#
# ---- BASE/BASE ---- [test.code.base] [test.dbf.base]
#
# Read TOPS register; confirm original TOPS
? 0x10003cc0 0x00000000 0xffffffff
# Test BASE instruction on PKE1
1 0x0300fedc_00000000_00000000_00000000 0x00000000 PPPP
# Attempt erroneous write to BASE register
! 0x10003ca0 0x0000dead
# Read BASE register; confirm proper 10-bit value
? 0x10003ca0 0x000002dc 0xffffffff
# Read TOPS register; confirm unmodified TOPS
? 0x10003cc0 0x00000000 0xffffffff
# Read STAT register; confirm DBF=0
? 0x10003c00 0x00000000 0x00000080
# Read DBF register; confirm DBF=0
? 0x10003cf0 0x00000000 0x00000001
#
#
# ---- OFFSET/OFST ---- [test.code.offset] [test.dbf.offset]
#
# Test OFFSET instruction on PKE1
1 0x0200ffff_00000000_00000000_00000000 0x00000000 PPPP
# Attempt erroneous write to OFFSET register
! 0x10003cb0 0x0000dead
# Read OFST register; confirm proper 10-bit value
? 0x10003cb0 0x000003ff 0xffffffff
# Read TOPS register; confirm recomputed TOPS
? 0x10003cc0 0x000002dc 0xffffffff
# Read STAT register; confirm DBF=0
? 0x10003c00 0x00000000 0x00000080
# Read DBF register; confirm DBF=0
? 0x10003cf0 0x00000000 0x00000001
# Read STAT register; confirm ER1 not set
? 0x10003c00 0x00000000 0x00002000
#
#
# ---- ITOP/ITOPS ---- [test.code.itop]
#
# Test ITOP instruction
0 0x0400ffff_00000000_00000000_00000000 0x00000000 PPPP
# Attempt erroneous write to ITOPS register
! 0x10003890 0x0000dead
# Read ITOPS register; confirm proper 10-bit value
? 0x10003890 0x000003ff 0xffffffff
# Read STAT register; confirm ER1 not set
? 0x10003800 0x00000000 0x00002000
#
#
# ---- STMOD/MODE ---- [test.code.stmod]
#
# Test STMOD instruction
0 0x05000003_00000000_00000000_00000000 0x00000000 PPPP
# Attempt erroneous write to MODE register
! 0x10003850 0x0000dead
# Read MODE register; confirm proper value
? 0x10003850 0x00000003 0xffffffff
# Test STMOD instruction with junk upper bits
0 0x0500dad1_00000000_00000000_00000000 0x00000000 PPPP
# Read MODE register; confirm proper value
? 0x10003850 0x00000001 0xffffffff
# Read STAT register; confirm ER1 not set
? 0x10003800 0x00000000 0x00002000
#
#
# ---- STMARK/MARK ---- [test.code.stmark]
#
# Test MARK instruction
0 0x0700abcd_00000000_00000000_00000000 0x00000000 PPPP
# Read STAT register; confirm MRK bit set
? 0x10003800 0x00000040 0x00000040
# Read MARK register
? 0x10003830 0x0000abcd 0xffffffff
# Write MARK register
! 0x10003830 0x00001234
# Read STAT register; confirm MRK bit clear
? 0x10003800 0x00000000 0x00000040
# Read MARK register
? 0x10003830 0x00001234 0xffffffff
#
#
# ---- bad PKEcode/ER1, interrupts ---- [test.code.bad] [test.stall.er1]
#
# A bad PKEcode
1 0x00000000_00000000_01000001_08000000 0x00000000 PPPP
# should put PKE into stalled mode, not executing following PKENOPs
# Read STAT register; confirm ER1 bit set
? 0x10003c00 0x00002000 0x00002000
# Read CODE register; confirm PKE is stuck just after bad code
? 0x10003c80 0x01000001 0xffffffff
# Reset PKE
! 0x10003c10 0x00000001
# Read STAT register; confirm ER1 no longer set
? 0x10003c00 0x00000000 0x00002000
# 
# Mask ME1 (ER1 stall) this time
! 0x10003c20 0x00000004
# Some bad PKEcodes (UNPACK with bad vn/vl) with ER1 masked [test.unpack.bad]
1 0x01000001_6b000000_77000000_63000000 0x00000000 PPPP
# should not put PKE into stalled mode, should execute following PKENOPs
# Read STAT register; confirm ER1 bit still set
? 0x10003c00 0x00002000 0x00002000
# Read CODE register; confirm PKE went past bad code
? 0x10003c80 0x01000001 0xffffffff
# Reset PKE
! 0x10003c10 0x00000001
#
# [test.stall.pis] [test.stall.int]
# A good PKEcode (STMOD) with interrupt
1 0x01000000_00000000_00000000_85000000 0x00000000 PPPP
# should put PKE into stalled mode, not executing following PKENOPs
# Read STAT register; confirm PIS & INT bits set, no ER1
? 0x10003c00 0x00000c00 0x00002c00
# Read CODE register; confirm PKE is stuck at bad code
? 0x10003c80 0x85000000 0xffffffff
# Resume PKE with STC
! 0x10003c10 0x00000008
# Read STAT register; confirm PIS & INT no longer set, no ER1
? 0x10003c00 0x00000000 0x00002c00
# Read CODE register; confirm PKE executed last instruction
? 0x10003c80 0x01000000 0xffffffff
#
# [test.stall.pis] [test.stall.int] [test.stall.int-masked]
# Mask INT stall: set ERR:MII
! 0x10003c20 0x00000001
# A good PKEcode (STMOD) with interrupt
1 0x01000001_00000000_00000000_85000000 0x00000000 PPPP
# should NOT put PKE into stalled mode
# Read STAT register; confirm INT bits set but no PIS, and no ER1
? 0x10003c00 0x00000800 0x00002c00
# Read CODE register; confirm PKE executed last instruction
? 0x10003c80 0x01000001 0xffffffff
#
# [test.stall.int-mark]
# Reset the PKE, unmasking interrupt
! 0x10003c10 0x00000001
# A good PKEcode (PKEMARK) with interrupt
1 0x01000002_01000001_0100000f_8700b00f 0x00000000 PPPP
# should NOT put PKE into stalled mode
# Read MARK register; confirm its value
? 0x10003c30 0x0000b00f 0xffffffff
# Read STAT register; confirm INT & PIS bits are set, and no ER1
? 0x10003c00 0x00000c00 0x00002c00
# Read CODE register; confirm PKE is stalled with following NOP instruction
? 0x10003c80 0x0100000f 0xffffffff
# Reset the PKE
! 0x10003c10 0x00000001
#
#
# ---- STMASK/MASK ---- [test.code.stmask]
#
# Test STMASK instruction; leave operand out for now
0 0x20000000_00000000_00000000_00000000 0x00000000 PPPP
# Read STAT register; confirm PPS field set at WAIT
? 0x10003800 0x00000001 0x00000003
# Add operand for STMASK instruction
0 0x00000000_00000000_00000000_1234abcd 0x00000000 PPP.
# Erroneous write to MASK register
! 0x10003870 0x98765432
# Read MASK register
? 0x10003870 0x1234abcd 0xffffffff
# Read STAT register; confirm ER1 not set
? 0x10003800 0x00000000 0x00002000
#
#
# ---- DIRECT/DIRECTHL ---- [test.code.direct] [test.code.directhl]
#
# Test DIRECT instruction; leave operand out for now
1 0x50000001_00000000_00000000_00000000 0x00000000 PPPP
# Read STAT register; confirm PPS field set at WAIT
? 0x10003c00 0x00000001 0x00000003
# Supply operand - it's a bad GPUIF tag
1 0x00000000_00000000_00000000_00000000 0x00000000 ....
# Test DIRECT instruction with bad operand alignment
1 0x00000000_50000001_00000000_00000000 0x00000000 PPPP
# Read STAT register; confirm ER1 bit set
? 0x10003c00 0x00002000 0x00002000
# Reset PKE
! 0x10003c10 0x00000001
# Reset GPUIF
! 0x10003000 0x00000001
# Read STAT register; confirm ER1 no longer set
? 0x10003c00 0x00000000 0x00002000
# Test DIRECTHL instruction with bad operand alignment
1 0x00000000_00000000_51000001_00000000 0x00000000 PPPP
# Read STAT register; confirm ER1 bit set
? 0x10003c00 0x00002000 0x00002000
# Reset PKE
! 0x10003c10 0x00000001
# Read STAT register; confirm ER1 no longer set
? 0x10003c00 0x00000000 0x00002000
# Test DIRECTHL instruction with bad operand alignment
1 0x00000000_00000000_00000000_51000001 0x00000000 PPPP
# Read STAT register; confirm ER1 bit set
? 0x10003c00 0x00002000 0x00002000
# Reset PKE
! 0x10003c10 0x00000001
# Read STAT register; confirm ER1 no longer set
? 0x10003c00 0x00000000 0x00002000
#
#
# ---- MPG - PKE0 ---- [test.code.mpg]
#
# Test MPG instruction; leave operand out for now
0 0x4a080000_00000000_00000000_00000000 0x00000000 PPPP
# Read STAT register; confirm PPS field set at WAIT
? 0x10003800 0x00000001 0x00000003
# Supply operands - eight two junk VU instruction word-pairs with real source-addr's
0 0xdeadbeef_0bad0bad_beef0bad_2bad2bad 0x00000010 ....
0 0xabcdbeef_44332211_12987423_95555999 0x00000100 ....
0 0xdeadabcd_75577588_beef0bad_89abcdef 0x00001000 ....
0 0xa5a5a5a5_5aaa5533_01234567_77889900 0x00010000 ....
# Check that instructions were loaded properly
? 0x11000000 0x2bad2bad 0xffffffff
? 0x11000004 0xbeef0bad 0xffffffff
? 0x11000014 0x12987423 0xffffffff
? 0x11000028 0x75577588 0xffffffff
? 0x1100003c 0xa5a5a5a5 0xffffffff
# Check that source addresses were loaded properly
? 0x21000000 0x00000010 0xffffffff
? 0x21000004 0x00000010 0xffffffff
? 0x21000008 0x00000100 0xffffffff
? 0x2100000c 0x00000100 0xffffffff
? 0x21000010 0x00001000 0xffffffff
? 0x21000014 0x00001000 0xffffffff
? 0x21000018 0x00010000 0xffffffff
? 0x2100001c 0x00010000 0xffffffff
# Test MPG instruction with bad operand alignment
0 0x00000000_4a020000_00000000_00000000 0x00000000 PPPP
# Read STAT register; confirm ER1 bit set
? 0x10003800 0x00002000 0x00002000
# Reset PKE
! 0x10003810 0x00000001
# Read STAT register; confirm ER1 no longer set
? 0x10003800 0x00000000 0x00002000
# Test MPG instruction with good operand alignment
0 0x00000000_00000000_4a010000_00000000 0x00000000 ..PP
# Read STAT register; confirm ER1 bit not set
? 0x10003800 0x00000000 0x00002000
# Test MPG instruction with bad operand alignment
0 0x00000000_00000000_00000000_4a010000 0x00000000 PPPP
# Read STAT register; confirm ER1 bit set
? 0x10003800 0x00002000 0x00002000
# Reset PKE
! 0x10003810 0x00000001
# Read STAT register; confirm ER1 no longer set
? 0x10003800 0x00000000 0x00002000
#
#
# ---- MPG - PKE1 ---- [test.code.mpg]
#
# Test MPG instruction; leave operand out for now
1 0x4a080000_00000000_00000000_00000000 0x00000000 PPPP
# Read STAT register; confirm PPS field set at WAIT
? 0x10003c00 0x00000001 0x00000003
# Supply operands - eight two junk VU instruction word-pairs with real source-addr's
1 0xdeadbeef_0bad0bad_beef0bad_2bad2bad 0x00000010 ....
1 0xabcdbeef_44332211_12987423_95555999 0x00000100 ....
1 0xdeadabcd_75577588_beef0bad_89abcdef 0x00001000 ....
1 0xa5a5a5a5_5aaa5533_01234567_77889900 0x00010000 ....
# Check that instructions were loaded properly
? 0x11008000 0x2bad2bad 0xffffffff
? 0x11008004 0xbeef0bad 0xffffffff
? 0x11008014 0x12987423 0xffffffff
? 0x11008028 0x75577588 0xffffffff
? 0x1100803c 0xa5a5a5a5 0xffffffff
# Check that source addresses were loaded properly
? 0x21008000 0x00000010 0xffffffff
? 0x21008004 0x00000010 0xffffffff
? 0x21008008 0x00000100 0xffffffff
? 0x2100800c 0x00000100 0xffffffff
? 0x21008010 0x00001000 0xffffffff
? 0x21008014 0x00001000 0xffffffff
? 0x21008018 0x00010000 0xffffffff
? 0x2100801c 0x00010000 0xffffffff
# Test MPG instruction with bad operand alignment
1 0x00000000_4a020000_00000000_00000000 0x00000000 PPPP
# Read STAT register; confirm ER1 bit set
? 0x10003c00 0x00002000 0x00002000
# Reset PKE
! 0x10003c10 0x00000001
# Read STAT register; confirm ER1 no longer set
? 0x10003c00 0x00000000 0x00002000
# Test MPG instruction with good operand alignment
1 0x00000000_00000000_4a010000_00000000 0x00000000 ..PP
# Read STAT register; confirm ER1 bit not set
? 0x10003c00 0x00000000 0x00002000
# Test MPG instruction with bad operand alignment
1 0x00000000_00000000_00000000_4a010000 0x00000000 PPPP
# Read STAT register; confirm ER1 bit set
? 0x10003c00 0x00002000 0x00002000
# Reset PKE
! 0x10003c10 0x00000001
# Read STAT register; confirm ER1 no longer set
? 0x10003c00 0x00000000 0x00002000
#
#
# ---- STROW/ROW + DMA mismatch ---- [test.code.strow] [test.dma.er0]
#
# Don't mask anything (including ER0)
! 0x10003820 0x00000000
# Test STROW instruction; leave operand out for now
0 0x30000000_00000000_00000000_00000000 0x00000000 PPPP
# Read STAT register; confirm PPS field set at WAIT
? 0x10003800 0x00000001 0x00000003
# Supply operand - four words
0 0x1234abcd_2345bcde_ffffffff_ffffffff 0x00000000 ..DD
# Read STAT register; confirm ER0 (DMA mismatch)
? 0x10003800 0x00001000 0x00001000
# Confirm that PKE is stalled at STROW instruction
? 0x10003880 0x30000000 0xffffffff
# Supply final few operand words
0 0x00000000_01000020_5432dcba_76543210 0x00000000 PP..
# Resume PKE with STC
! 0x10003810 0x00000008
# Make erroneous write
! 0x10003900 0x11111111
! 0x10003910 0x22222222
! 0x10003920 0x33333333
! 0x10003930 0x44444444
# Check row registers for value
? 0x10003900 0x2345bcde 0xffffffff
? 0x10003910 0x1234abcd 0xffffffff
? 0x10003920 0x76543210 0xffffffff
? 0x10003930 0x5432dcba 0xffffffff
# Reset PKE
! 0x10003810 0x00000001
#
#
# ---- STCOL/COL + STOP/CONTINUE ---- [test.code.stcol] [test.stall.fbk] [test.stall.pfs]
#
# Test STCOL instruction; leave operand out for now
0 0x31000000_00000000_00000000_00000000 0x00000000 PPPP
# Read STAT register; confirm PPS field set at WAIT
? 0x10003800 0x00000001 0x00000003
# Stop PKE with FBK bit
! 0x10003810 0x00000002
# Supply operand - four words
0 0x1234abcd_2345bcde_5432dcba_76543210 0x00000000 ....
# Confirm that PKE is continuing to stall due to FBK
? 0x10003800 0x00000200 0x00000200
? 0x10003800 0x00000200 0x00000200
? 0x10003800 0x00000200 0x00000200
# Resume PKE with STC bit
! 0x10003810 0x00000008
# Read STAT register; confirm FBK no longer set
? 0x10003800 0x00000000 0x00000200
# Check column registers for value
? 0x10003940 0x76543210 0xffffffff
? 0x10003950 0x5432dcba 0xffffffff
? 0x10003960 0x2345bcde 0xffffffff
? 0x10003970 0x1234abcd 0xffffffff
# Read STAT register; confirm ER1 not set
? 0x10003800 0x00000000 0x00002000
#
# Try stopping using STP bit this time
# [test.stall.stp]  [test.stall.wait] [test.stall.pss]
# Test STCOL instruction; leave operand out for now
1 0x31000000_00000000_00000000_00000000 0x00000000 PPPP
# Read STAT register; confirm PPS field set at WAIT
? 0x10003c00 0x00000001 0x00000003
# Stop PKE after current instruction with STP bit
! 0x10003c10 0x00000004
# Supply operand - four words
1 0x1234abcd_2345bcde_5432dcba_76543210 0x00000000 ....
# Check column registers for value
? 0x10003d40 0x76543210 0xffffffff
? 0x10003d50 0x5432dcba 0xffffffff
? 0x10003d60 0x2345bcde 0xffffffff
? 0x10003d70 0x1234abcd 0xffffffff
# Now send a new instruction with operands; this should stall
1 0x31000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x11111111_22222222_33333333_44444444 0x00000000 ....
# Confirm that PKE is continuing to stall due to PSS
? 0x10003c00 0x00000100 0x00000100
? 0x10003c00 0x00000100 0x00000100
? 0x10003c00 0x00000100 0x00000100
# Resume PKE with STC bit; it should process pent-up STCOL
! 0x10003c10 0x00000008
# Check column registers for value
? 0x10003d40 0x44444444 0xffffffff
? 0x10003d50 0x33333333 0xffffffff
? 0x10003d60 0x22222222 0xffffffff
? 0x10003d70 0x11111111 0xffffffff
# Read STAT register; confirm ER1 not set
? 0x10003c00 0x00000000 0x00002000
#
#
# ---- MSKPATH3 ---- [test.code.mskpath3]
#
# Clear & set MSKPATH3 on PKE1
1 0x06008000_00000000_06000000_00000000 0x00000000 PPPP
# Check M3P & M3R fields of GPUIF STAT
? 0x10003020 0x00000002 0x00000003
# Clear MSKPATH3
1 0x06000000_00000000_00000000_00000000 0x00000000 PPPP
# Check M3P & M3R fields of GPUIF STAT
? 0x10003020 0x00000000 0x00000003
# Read STAT register; confirm ER1 not set
? 0x10003c00 0x00000000 0x00002000
# Erroneously run this on PKE0
0 0x06008000_00000000_06000000_00000000 0x00000000 PPPP
# Read STAT register; confirm ER1 set
? 0x10003800 0x00002000 0x00002000
# Reset PKE0
! 0x10003810 0x00000001
#
#
# ---- memory-mapped port reading ---- [test.mmap]
#
# Erroneously read words from FIFO ports
? 0x10004000 0x00000000 0xffffffff
? 0x10004004 0x00000000 0xffffffff
? 0x10004008 0x00000000 0xffffffff
? 0x1000400c 0x00000000 0xffffffff
? 0x10005000 0x00000000 0xffffffff
? 0x10005004 0x00000000 0xffffffff
? 0x10005008 0x00000000 0xffffffff
? 0x1000500c 0x00000000 0xffffffff
#
# Erroneously read PKE1-only registers on PKE0
? 0x100038a0 0x00000000 0xffffffff
? 0x100038b0 0x00000000 0xffffffff
? 0x100038c0 0x00000000 0xffffffff
? 0x100038e0 0x00000000 0xffffffff
? 0x100038f0 0x00000000 0xffffffff
#
# Erroneously write PKE1-only registers on PKE0
! 0x100038a0 0x00000000
! 0x100038b0 0x00000000
! 0x100038c0 0x00000000
! 0x100038e0 0x00000000
! 0x100038f0 0x00000000
#
# Erroneously read write-only registers
? 0x10003810 0x00000000 0xffffffff
? 0x10003c10 0x00000000 0xffffffff
#
# Erroneously write read-only registers
! 0x10003c00 0x00000000
! 0x10003c40 0x00000000
! 0x10003c50 0x00000000
! 0x10003c60 0x00000000
! 0x10003c70 0x00000000
! 0x10003c80 0x00000000
! 0x10003c90 0x00000000
! 0x10003ca0 0x00000000
! 0x10003cb0 0x00000000
! 0x10003cc0 0x00000000
! 0x10003cd0 0x00000000
! 0x10003ce0 0x00000000
! 0x10003cf0 0x00000000
! 0x10003d00 0x00000000
! 0x10003d10 0x00000000
! 0x10003d20 0x00000000
! 0x10003d30 0x00000000
! 0x10003d40 0x00000000
! 0x10003d50 0x00000000
! 0x10003d60 0x00000000
! 0x10003d70 0x00000000
#
# Erroneously read/write words between registers
! 0x10003c14 0xffffffff
! 0x10003c18 0xffffffff
! 0x10003c1c 0xffffffff
! 0x10003874 0xffffffff
! 0x10003884 0xffffffff
! 0x100038fc 0xffffffff
#
#
# ---- FLUSH/FLUSHE/FLUSHA & CALL/CALLF/CONT ---- [test.code.flush] [test.code.flushe]
# [test.code.flusha] [test.code.pkemscal] [test.code.pkemscalf] [test.code.pkemscnt]
# [test.stall.vu]
#
# Load a bunch of NOP[e]/NOP instructions into the VU
# 0x000002ff_8000033c == NOP NOP
# 0x400002ff_8000033c == NOP[e] NOP
# MPG 18 instructions
1 0x4a120001_00000000_00000000_00000000 0x00000000 PPPP
1 0x000002ff_8000033c_000002ff_8000033c 0x00000000 ....
1 0x000002ff_8000033c_000002ff_8000033c 0x00000000 ....
1 0x000002ff_8000033c_000002ff_8000033c 0x00000000 ....
1 0x000002ff_8000033c_000002ff_8000033c 0x00000000 ....
1 0x000002ff_8000033c_000002ff_8000033c 0x00000000 ....
1 0x000002ff_8000033c_000002ff_8000033c 0x00000000 ....
1 0x000002ff_8000033c_400002ff_8000033c 0x00000000 ....
1 0x400002ff_8000033c_000002ff_8000033c 0x00000000 ....
1 0x400002ff_8000033c_000002ff_8000033c 0x00000000 ....
# Start VU; FLUSH
1 0x14000000_14000000_00000000_00000000 0x00000000 PPPP
# Assert PEW bit on while waiting for VU
? 0x10003c00 0x00000004 0x00000004
# Send a few more NOPs to let VU get to first END
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
# Assert VU is in idle state
? 0x110073d0 0x00000000 0x00000200
# Resume/run/run/resume to check stall logic in PKEMSCNT/PKEMSCALF/PKEMSCAL
1 0x13000000_14000000_11000000_15000000 0x00000000 PPPP
1 0x14000000_15000000_10000000_17000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
1 0x00000000_00000000_00000000_00000000 0x00000000 PPPP
# Assert VU is in idle state
? 0x110073d0 0x00000000 0x00000200
#
#
# ---- DBF ---- [test.code.base] [test.code.offset] [test.dbf]
# [test.code.pkemscal] [test.code.pkemscalf] [test.code.pkemscnt]
#
# Load a bunch of NOP[e]/NOP instructions into the VU
# 0x000002ff_8000033c == NOP NOP
# 0x400002ff_8000033c == NOP[e] NOP
# MPG 10 instructions with lots of ENDs
1 0x4a0a0000_00000000_00000000_00000000 0x00000000 PPPP
1 0x400002ff_8000033c_000002ff_8000033c 0x00000000 ....
1 0x000002ff_8000033c_000002ff_8000033c 0x00000000 ....
1 0x000002ff_8000033c_400002ff_8000033c 0x00000000 ....
1 0x400002ff_8000033c_000002ff_8000033c 0x00000000 ....
1 0x000002ff_8000033c_000002ff_8000033c 0x00000000 ....
# Load BASE & OFFSET registers; stick in some DMA tags too [test.dma]
1 0x02000200_03000100_77777777_77777777 0x00000000 PPDD
# Confirm BASE & OFFSET & TOPS & TOP & DBF registers
? 0x10003ca0 0x00000100 0xffffffff
? 0x10003cb0 0x00000200 0xffffffff
? 0x10003cc0 0x00000100 0xffffffff
? 0x10003ce0 0x00000000 0xffffffff
? 0x10003cf0 0x00000000 0xffffffff
# Make one CALL
1 0x00000000_00000000_00000000_14000000 0x00000000 PPPP
# Confirm TOP & DBF & TOPS registers after DBF flip
? 0x10003ce0 0x00000100 0xffffffff
? 0x10003cf0 0x00000001 0xffffffff
? 0x10003cc0 0x00000300 0xffffffff
# Make one CALLF
1 0x00000000_00000000_00000000_15000000 0x00000000 PPPP
# Confirm TOP & DBF & TOPS registers after DBF flip
? 0x10003ce0 0x00000300 0xffffffff
? 0x10003cf0 0x00000000 0xffffffff
? 0x10003cc0 0x00000100 0xffffffff
# Make one CONT
1 0x00000000_00000000_00000000_17000000 0x00000000 PPPP
# Confirm TOP & DBF & TOPS registers after DBF flip
? 0x10003ce0 0x00000100 0xffffffff
? 0x10003cf0 0x00000001 0xffffffff
? 0x10003cc0 0x00000300 0xffffffff
#
#
# ---- MPG/UNPACK address overflow tests ---- 
#
# RESET PKE0
! 0x10003810 0x00000001
# UNPACK to PKE0 near top of address range
# [test.unpack.V3_32] [test.code.stcycl] [test.unpack.endian] [test.unpack.unsigned]
# [test.unpack.no-r] [test.ext.unpackaddr] [test.track.unpack]
0 0x6804ffff_01000101_77777777_55555555 0x00000ff0 PPDD
0 0x33330333_22222022_11111101_ccccccc0 0x0000ff00 ....
0 0x07777777_60666666_55055555_44404444 0x000ff000 ....
0 0xbbbb0bbb_aaaaa0aa_99999909_88888880 0x00ff0000 ....
# Assert that all words were written correctly
? 0x11004ff0 0xccccccc0 0xffffffff
? 0x11004ff4 0x11111101 0xffffffff
? 0x11004ff8 0x22222022 0xffffffff
? 0x11004ffc 0x00000000 0xffffffff
? 0x210043fc 0x0000ff00 0xffffffff
? 0x11004000 0x33330333 0xffffffff
? 0x11004004 0x44404444 0xffffffff
? 0x11004008 0x55055555 0xffffffff
? 0x1100400c 0x00000000 0xffffffff
? 0x21004000 0x000ff000 0xffffffff
? 0x11004010 0x60666666 0xffffffff
? 0x11004014 0x07777777 0xffffffff
? 0x11004018 0x88888880 0xffffffff
? 0x1100401c 0x00000000 0xffffffff
? 0x21004004 0x00ff0000 0xffffffff
? 0x11004020 0x99999909 0xffffffff
? 0x11004024 0xaaaaa0aa 0xffffffff
? 0x11004028 0xbbbb0bbb 0xffffffff
? 0x1100402c 0x00000000 0xffffffff
? 0x21004008 0x00ff0000 0xffffffff
#
# RESET PKE1
! 0x10003c10 0x00000001
# UNPACK to PKE1 near top of PKE1 address range [test.unpack.V4_5]
# [test.unpack.signed] [test.unpack.r] [test.ext.unpackaddr]
1 0x02000100_00000100_99999999_33333333 0x0ff00000 PPDD
1 0x6f05bfff_01000101_77777777_55555555 0x00ff0000 PPDD
1 0x00000000_77779999_deadbeef_aaaa5555 0x000ff000 P...
# Assert that all words were written correctly
? 0x1100fff0 0xfffffff5 0xffffffff
? 0x1100fff4 0x0000000a 0xffffffff
? 0x1100fff8 0xfffffff5 0xffffffff
? 0x1100fffc 0x00000000 0xffffffff
? 0x2100cffc 0x000ff000 0xffffffff
? 0x1100c000 0x0000000a 0xffffffff
? 0x1100c004 0xfffffff5 0xffffffff
? 0x1100c008 0x0000000a 0xffffffff
? 0x1100c00c 0x00000001 0xffffffff
? 0x2100c000 0x000ff000 0xffffffff
? 0x1100c010 0x0000000f 0xffffffff
? 0x1100c014 0xfffffff7 0xffffffff
? 0x1100c018 0x0000000f 0xffffffff
? 0x1100c01c 0x00000001 0xffffffff
? 0x2100c004 0x000ff000 0xffffffff
? 0x1100c020 0x0000000d 0xffffffff
? 0x1100c024 0xfffffff5 0xffffffff
? 0x1100c028 0xfffffff7 0xffffffff
? 0x1100c02c 0x00000001 0xffffffff
? 0x2100c008 0x000ff000 0xffffffff
? 0x1100c030 0xfffffff9 0xffffffff
? 0x1100c034 0x0000000c 0xffffffff
? 0x1100c038 0x00000006 0xffffffff
? 0x1100c03c 0x00000001 0xffffffff
? 0x2100c00c 0x000ff000 0xffffffff
#
#
# MPG to PKE0 near top of address range
# [test.mpg] [test.mpg.endian] [test.ext.mpgaddr] [test.track.mpg]
#
0 0x4a04ffff_01000000_77777777_55555555 0x0000ee00 PPDD
0 0x33330333_22222022_11111101_ccccccc0 0x000ee000 ....
0 0x07777777_60666666_55055555_44404444 0x00ee0000 ....
# Assert that all words were written correctly
? 0x11000ff8 0xccccccc0 0xffffffff
? 0x11000ffc 0x11111101 0xffffffff
? 0x210007fc 0x000ee000 0xffffffff
? 0x11000000 0x22222022 0xffffffff
? 0x11000004 0x33330333 0xffffffff
? 0x21000000 0x000ee000 0xffffffff
? 0x11000008 0x44404444 0xffffffff
? 0x1100000c 0x55055555 0xffffffff
? 0x21000004 0x00ee0000 0xffffffff
? 0x11000010 0x60666666 0xffffffff
? 0x11000014 0x07777777 0xffffffff
? 0x21000008 0x00ee0000 0xffffffff
#
# MPG to PKE1 near top of address range
# [test.mpg] [test.mpg.endian] [test.ext.mpgaddr] [test.track.mpg]
#
1 0x4a04ffff_01000000_77777777_55555555 0x0000ee00 PPDD
1 0x33330333_22222022_11111101_ccccccc0 0x000ee000 ....
1 0x07777777_60666666_55055555_44404444 0x00ee0000 ....
# Assert that all words were written correctly
? 0x1100bff8 0xccccccc0 0xffffffff
? 0x1100bffc 0x11111101 0xffffffff
? 0x21009ffc 0x000ee000 0xffffffff
? 0x11008000 0x22222022 0xffffffff
? 0x11008004 0x33330333 0xffffffff
? 0x21008000 0x000ee000 0xffffffff
? 0x11008008 0x44404444 0xffffffff
? 0x1100800c 0x55055555 0xffffffff
? 0x21008004 0x00ee0000 0xffffffff
? 0x11008010 0x60666666 0xffffffff
? 0x11008014 0x07777777 0xffffffff
? 0x21008008 0x00ee0000 0xffffffff
#
#
# UNPACK with MASK & MODE processing
# [test.unpack.mask] [test.unpack.mode.2] [test.unpack.cycle.0.1]
#
# RESET PKE0
! 0x10003810 0x00000001
#
# Preset VU0 data memory to funky words
# Set registers COL / ROW / MASK=10 for rows>0 / MODE=2 / CYCLE=0001
0 0xaaffaa00_20000000_05000002_01000001 0x00000000 .PPP
# STROW: increment
0 0x30000000_00000000_00000000_00000000 0x00000000 PPPP
0 0x00000040_00000030_00000020_00000010 0x00000000 ....
# STCOL: initial values for accumulator
0 0x31000000_00000000_00000000_00000000 0x00000000 PPPP
0 0x00004000_00003000_00002000_00001000 0x00000000 ....
# Unpack 256 V4_8 vectors, w/ values from ROWS regs
0 0xffffffff_7e000000_00000000_00000000 0x00000000 .PPP
# Confirm appropriate values filled: ROW0 - 1
? 0x11004000 0x0000000f 0xffffffff
? 0x11004004 0x0000001f 0xffffffff
? 0x11004008 0x0000002f 0xffffffff
? 0x1100400c 0x0000003f 0xffffffff
# this should be COL1
? 0x11004010 0x00002000 0xffffffff
? 0x11004014 0x00002000 0xffffffff
? 0x11004018 0x00002000 0xffffffff
? 0x1100401c 0x00002000 0xffffffff
# this should be the old data (write-inhibited) [test.mask.write-inhibit]
? 0x11004020 0x99999909 0xffffffff
? 0x11004024 0xaaaaa0aa 0xffffffff
? 0x11004028 0xbbbb0bbb 0xffffffff
? 0x1100402c 0x00000000 0xffffffff
# these should be COL3 [test.mask.col3clamp]
? 0x11004030 0x00004000 0xffffffff
? 0x11004034 0x00004000 0xffffffff
? 0x11004038 0x00004000 0xffffffff
? 0x1100403c 0x00004000 0xffffffff
? 0x11004050 0x00004000 0xffffffff
? 0x11004054 0x00004000 0xffffffff
? 0x11004058 0x00004000 0xffffffff
? 0x1100405c 0x00004000 0xffffffff
#
#
# UNPACK with MASK=0 & MODE=2 processing
# [test.unpack.nomask] [test.unpack.mode.2] [test.unpack.cycle.0.1]
#
# RESET PKE0
! 0x10003810 0x00000001
#
# Preset VU0 data memory to funky words
# Set registers COL / ROW / MODE=2 / CYCLE=0101
0 0x00000000_00000000_05000002_01000101 0x00000000 PPPP
# STROW: initial values for accumulator
0 0x30000000_00000000_00000000_00000000 0x00000000 PPPP
0 0x00000040_00000030_00000020_00000010 0x00000000 ....
# Unpack 4 V1_8 vectors
0 0x10080402_62040010_00000000_00000000 0x00000000 .PPP
# Confirm appropriate values filled: ROW0 - 1
? 0x11004100 0x00000012 0xffffffff
? 0x11004104 0x00000022 0xffffffff
? 0x11004108 0x00000032 0xffffffff
? 0x1100410c 0x00000042 0xffffffff
# 
? 0x11004110 0x00000016 0xffffffff
? 0x11004114 0x00000026 0xffffffff
? 0x11004118 0x00000036 0xffffffff
? 0x1100411c 0x00000046 0xffffffff
# 
? 0x11004120 0x0000001e 0xffffffff
? 0x11004124 0x0000002e 0xffffffff
? 0x11004128 0x0000003e 0xffffffff
? 0x1100412c 0x0000004e 0xffffffff
# 
? 0x11004130 0x0000002e 0xffffffff
? 0x11004134 0x0000003e 0xffffffff
? 0x11004138 0x0000004e 0xffffffff
? 0x1100413c 0x0000005e 0xffffffff
#
# Set registers ROW / MASK / MODE=1 / CYCLE=0101
0 0x00000000_20000000_05000001_01000101 0x00000000 .PPP
# STROW: initial values for accumulator
0 0x30000000_00000000_00000000_00000000 0x00000000 PPPP
0 0x0000ff00_0000ee00_0000dd00_0000cc00 0x00000000 ....
# Unpack one V1_8 vector [test.unpack.1.8] [test.unpack.unsigned]
0 0x00000000_00000000_000000cc_72014000 0x00000000 PP.P
# Confirm
? 0x11004000 0x0000cccc 0xffffffff
? 0x11004004 0x0000ddcc 0xffffffff
? 0x11004008 0x0000eecc 0xffffffff
? 0x1100400c 0x0000ffcc 0xffffffff
# Unpack one V2_8 vector [test.unpack.2.8] [test.unpack.unsigned]
0 0x00000000_00000000_000077cc_76014010 0x00000000 PP.P
# Confirm
? 0x11004100 0x0000cccc 0xffffffff
? 0x11004104 0x0000dd77 0xffffffff
? 0x11004108 0x0000ee00 0xffffffff
? 0x1100410c 0x0000ff00 0xffffffff
